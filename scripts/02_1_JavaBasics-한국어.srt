1
00:00:00,000 --> 00:00:04,390
이 강의에서는 Java 언어에서 객체지향 부분 이전에

2
00:00:04,390 --> 00:00:08,100
기본이 되는 프로그래밍 부분에 대해 강의하겠습니다.

3
00:00:08,100 --> 00:00:09,300
페이지 2

4
00:00:09,300 --> 00:00:13,560
먼저 Java program의 일반적인 구조에 대해 알아보겠습니다.

5
00:00:13,560 --> 00:00:17,900
Java program은 모든 내용이 class의 일부가 되어야 하기 때문에

6
00:00:17,900 --> 00:00:20,620
어쨋든 class를 정의해야 합니다.

7
00:00:20,620 --> 00:00:25,110
이 예제 에서는 HelloWorld1이라는 class가 정의되어 있습니다.

8
00:00:25,110 --> 00:00:29,130
public은 access modifier라고 불리는 keyword인데

9
00:00:29,130 --> 00:00:33,730
이 class가 어떤 다른 class에서도 사용될 수 있다는 뜻입니다.

10
00:00:33,730 --> 00:00:37,390
class는 class type을 정의하는 keyword입니다.

11
00:00:37,390 --> 00:00:42,200
그 뒤에 class 이름이 나오는데 이 예에서는 HelloWorld1 입니다.

12
00:00:42,200 --> 00:00:45,130
이전에도 언급했지만 class의 이름은

13
00:00:45,130 --> 00:00:48,370
java source file의 이름과 일치해야 합니다.

14
00:00:48,370 --> 00:00:51,920
Class body의 시작은 왼쪽 brace { 로 열고

15
00:00:51,920 --> 00:00:55,500
class의 끝은 오른쪽 brace } 로 닫게 됩니다.

16
00:00:55,500 --> 00:00:56,780
페이지 3

17
00:00:56,780 --> 00:01:01,720
Class body안에는 class에 속한 data를 나타내는 각종 field와

18
00:01:01,720 --> 00:01:05,350
operation을 나타내는 method들이 존재합니다.

19
00:01:05,350 --> 00:01:10,260
이 예제의 class는 data, 즉, field를 가지지 않고 있습니다.

20
00:01:10,260 --> 00:01:13,550
다만 하나의 method인 main을 가지고 있습니다.

21
00:01:13,550 --> 00:01:18,410
Main method는 프로그램이 시작될 때 처음 실행되는 method입니다.

22
00:01:18,410 --> 00:01:22,620
따라서 실행이 가능한 프로그램 (class) 일 경우

23
00:01:22,620 --> 00:01:25,490
Main method를 반드시 가져야 합니다.

24
00:01:25,490 --> 00:01:26,770
페이지 4

25
00:01:26,770 --> 00:01:30,060
main method의 header에 가장 먼저 나오는 것은

26
00:01:30,060 --> 00:01:33,610
역시 access modifier인 public 입니다.

27
00:01:33,610 --> 00:01:37,400
이 public은 OS에서 프로그램을 실행하기 위해

28
00:01:37,400 --> 00:01:41,000
main을 call 할 수 있게 한다라고 이해하면 되겠습니다.

29
00:01:41,000 --> 00:01:45,260
다음에 나오는 static은 main method가 이 class 내에서

30
00:01:45,260 --> 00:01:48,210
Static method 라는 것을 나타내는데

31
00:01:48,210 --> 00:01:52,890
간단히 말하면 이 class를 틀로 만들어지는 모든 object가

32
00:01:52,890 --> 00:01:56,340
단 하나의 main method를 공유한다는 뜻입니다.

33
00:01:56,340 --> 00:02:00,050
아직 static 의 의미를 모두 이해하기 힘들 수 있으나

34
00:02:00,050 --> 00:02:02,900
나중에 자세히 학습하도록 하겠습니다.

35
00:02:02,900 --> 00:02:07,080
void는 main method의 return value가 없다는 뜻입니다.

36
00:02:07,080 --> 00:02:10,710
Method, 즉, function은 흔히 어떤 value를

37
00:02:10,710 --> 00:02:13,920
Return 할 수도 있고 그렇지 않을 수도 있습니다.

38
00:02:13,920 --> 00:02:19,220
f(a, b) = a + b 라는 function f가 있다고 하면

39
00:02:19,220 --> 00:02:23,090
Return value는 a + b 가 될 수 있을 것입니다.

40
00:02:23,090 --> 00:02:27,580
그러나 어떤 function (method) 는 return value 없이

41
00:02:27,580 --> 00:02:31,370
일련의 작업만을 연속적으로 실행할 수도 있습니다.

42
00:02:31,370 --> 00:02:33,980
main은 method의 이름을 말합니다.

43
00:02:33,980 --> 00:02:37,450
그 뒤에 괄호안에 들어있는 String[] args 는

44
00:02:37,450 --> 00:02:39,980
parameter의 type과 이름입니다.

45
00:02:39,980 --> 00:02:44,240
이전의 예에서 f(a, b) 라는 function, 즉, method에서는

46
00:02:44,240 --> 00:02:47,240
a와 b라는 두 개의 parameter를 받아

47
00:02:47,240 --> 00:02:49,750
어떤 계산을 하게 되어있습니다.

48
00:02:49,750 --> 00:02:52,010
Main method의 경우 이 parameter를

49
00:02:52,010 --> 00:02:54,950
Command line arguments라고 부르는데

50
00:02:54,950 --> 00:02:59,050
프로그램을 실행하는 명령에 붙이는 parameter를 말합니다.

51
00:02:59,050 --> 00:03:04,300
예를 들면 “javac -version” 이라는 프로그램을 실행했다고 하면

52
00:03:04,300 --> 00:03:07,220
javac는 프로그램이 이름이고

53
00:03:07,220 --> 00:03:11,590
-version은 command line arguments로 프로그램에 전달됩니다.

54
00:03:11,590 --> 00:03:16,470
그러나 우리는 아직 이 command line arguments를 이용하지는 않고 있습니다.

55
00:03:16,470 --> 00:03:18,770
String[] 에서 bracket 기호는

56
00:03:18,770 --> 00:03:22,900
args가 String의 array type이라는 것을 말하고 있습니다.

57
00:03:22,900 --> 00:03:27,310
예를 들어 “foo 3 Seoul 7” 이라는 프로그램 실행을 고려하면

58
00:03:27,310 --> 00:03:33,340
args[0] = “3”, args[1] = “Seoul”, args[2] = “7” 이 되겠습니다.

59
00:03:33,340 --> 00:03:34,650
페이지 5

60
00:03:34,650 --> 00:03:39,120
Java의 comment는 C나 C++와 같은 형식입니다.

61
00:03:39,120 --> 00:03:43,170
먼저, 슬래쉬 스타 /* 로 시작하여 스타 슬래쉬 */ 로 끝내는

62
00:03:43,170 --> 00:03:45,470
멀티라인 코멘트가 있습니다.

63
00:03:45,470 --> 00:03:49,020
특별히 슬래쉬 더블스타로 시작할 수도 있는데

64
00:03:49,020 --> 00:03:53,360
이 경우는 Java의 utility 중 하나인 JavaDoc을 이용하여

65
00:03:53,360 --> 00:03:58,580
API documentation 을 자동으로 만들어 주는 기능을 이용할 수 있습니다.

66
00:03:58,580 --> 00:04:03,070
그러나 여기에 대해서는 더 이상 이 코스에서 언급하지 않겠으며

67
00:04:03,070 --> 00:04:07,150
필요한 경우 다른 참고자료들을 찾아 보시기 바랍니다.

68
00:04:07,150 --> 00:04:10,940
싱글라인 comment는 더블 슬래쉬 // 로 시작하면 되고

69
00:04:10,940 --> 00:04:14,390
같은 줄의 끝까지 모두 comment로 간주 됩니다.

70
00:04:14,390 --> 00:04:15,670
페이지 6

71
00:04:15,670 --> 00:04:18,700
다음은 statement block에 관한 것인데

72
00:04:18,700 --> 00:04:22,930
Left brace { 로 시작하여 right brace } 로 닫습니다.

73
00:04:22,930 --> 00:04:27,660
이 block은 local variable들을 위한 새로운 scope를 만들면서

74
00:04:27,660 --> 00:04:33,170
If, for, while 문 등에서 body를 이루는 multiple statement들을

75
00:04:33,170 --> 00:04:35,360
묶어 주는 역할을 합니다.

76
00:04:35,360 --> 00:04:39,020
물론 method 전체의 시작과 끝도 하나의 block으로

77
00:04:39,020 --> 00:04:43,670
Class 전체의 시작과 끝도 하나의 block으로 간주할 수 있겠습니다.

78
00:04:43,670 --> 00:04:48,610
variable의 scope에 대해서는 나중에 더 자세히 강의할 예정입니다.

79
00:04:48,610 --> 00:04:49,970
페이지 7

80
00:04:49,970 --> 00:04:53,840
다음은 identifier, 즉, 식별자 입니다.

81
00:04:53,840 --> 00:04:58,860
Identifier는 간단히 말해 프로그래머가 새로 지어내야 할 이름인데,

82
00:04:58,860 --> 00:05:04,660
Variable, constant, method, parameter, class 등의 이름을 말합니다.

83
00:05:04,660 --> 00:05:09,620
Java의 identifier에는 case sensitive rule이 적용됩니다.

84
00:05:09,620 --> 00:05:15,920
즉, 알파벳 대문자와 소문자가 사용된 경우 다른 identifier로 인식합니다.

85
00:05:15,920 --> 00:05:22,160
또, Java 문법에서 사용되고 있는 keyword는 identifier로 사용될 수 없습니다.

86
00:05:22,160 --> 00:05:26,030
예를 들면 class, public, void 등 입니다.

87
00:05:26,030 --> 00:05:30,260
Identifier 이름을 짓는데 반드시 따라야 하는 rule은

88
00:05:30,260 --> 00:05:32,900
Numeric character로 시작할 수 없으며

89
00:05:32,900 --> 00:05:36,790
달러 싸인 ($) 과 언더바 ( _ ) 이외에 다른 special character는

90
00:05:36,790 --> 00:05:39,560
사용될 수 없다는 두가지 뿐입니다.

91
00:05:39,560 --> 00:05:42,120
그러나 일반적으로 Java 언어에서

92
00:05:42,120 --> 00:05:45,250
identifier 이름을 짓는 convention이 있는데,

93
00:05:45,250 --> 00:05:48,440
variable과 methods는 camelCase, 즉,

94
00:05:48,440 --> 00:05:53,660
소문자로 시작하고, 단어가 바뀔 때 시작 문자를 대문자로 하는 것과

95
00:05:53,660 --> 00:05:56,320
Class 이름은 PascalCase, 즉,

96
00:05:56,320 --> 00:06:01,520
대문자로 시작하고, 단어가 바뀔 때 시작 문자를 대문자로 하는 것이

97
00:06:01,520 --> 00:06:03,400
권장되고 있습니다.

98
00:06:03,400 --> 00:06:04,760
페이지 8

99
00:06:04,760 --> 00:06:07,840
Java의 data type에는 크게 두 가지가 있는데,

100
00:06:07,840 --> 00:06:10,580
첫번째는 Primitive type이고

101
00:06:10,580 --> 00:06:13,380
두번째는 Reference type 입니다.

102
00:06:13,380 --> 00:06:16,590
Primitive type은 정수, 실수 등으로

103
00:06:16,590 --> 00:06:20,140
기본적으로 value 1개 만을 가지는 타입입니다.

104
00:06:20,140 --> 00:06:24,240
따라서 Primitive type은 class로 취급되지 않습니다.

105
00:06:24,240 --> 00:06:28,970
반면에 reference type은 String과 같은 모든 class들과

106
00:06:28,970 --> 00:06:32,340
Array, enumeration 등의 type을 말합니다.

107
00:06:32,340 --> 00:06:37,150
엄밀히 말하면 reference는 memory의 address와 같은 개념으로

108
00:06:37,150 --> 00:06:41,330
class와 같은 복잡한 data가 모여있는 memory의 주소를

109
00:06:41,330 --> 00:06:44,600
그 value로 가지고 있다고 보면 되겠습니다.

110
00:06:44,600 --> 00:06:49,170
Reference type에 대해서는 추후 더 자세히 학습할 것입니다.

111
00:06:49,170 --> 00:06:55,570
Primitive type에는 정수형, 실수형, 캐릭터형, 불리안형의 네가지가 있는데,

112
00:06:55,570 --> 00:06:59,910
정수형에는 8bits (즉, 1 byte) 의 byte type,

113
00:06:59,910 --> 00:07:03,380
16bits (2 bytes)의 short type,

114
00:07:03,380 --> 00:07:07,120
32bits (4 bytes)의 int type,

115
00:07:07,120 --> 00:07:11,330
64bits (8 bytes)의 long type 의

116
00:07:11,330 --> 00:07:13,320
4가지 type이 있습니다.

117
00:07:13,320 --> 00:07:18,880
실수형에는 32bits의 float, 64bits의 double이 있습니다.

118
00:07:18,880 --> 00:07:22,430
캐릭터형에는 16bits의 char 가 있습니다.

119
00:07:22,430 --> 00:07:27,180
불리안형에는 true나 false 중 한가지 value를 가질 수 있는

120
00:07:27,180 --> 00:07:29,220
boolean type이 있습니다.

121
00:07:29,220 --> 00:07:30,580
페이지 9

122
00:07:30,580 --> 00:07:34,370
Data type에 대한 example 프로그램을 보겠습니다.

123
00:07:34,370 --> 00:07:38,050
먼저 int type인 myNumber를 declare하였고

124
00:07:38,050 --> 00:07:40,900
그 value를 10으로 초기화 하였습니다.

125
00:07:40,900 --> 00:07:45,940
yourNumber의 경우처럼 declaration과 초기화를 한번에 하기도 합니다.

126
00:07:45,940 --> 00:07:51,350
literal은 여기서 직접적으로 주어지는 숫자, 문자, 문자열 등을 말하는데요,

127
00:07:51,350 --> 00:07:55,090
float type f1에 literal을 assign할 경우에

128
00:07:55,090 --> 00:07:58,980
숫자 맨 뒤에 f를 붙여 double과 구분해야 합니다.

129
00:07:58,980 --> 00:08:03,030
대신에 double type에 literal을 assign할 경우에는

130
00:08:03,030 --> 00:08:05,280
그냥 숫자만 쓰면 됩니다.

131
00:08:05,280 --> 00:08:06,560
페이지 10

132
00:08:06,560 --> 00:08:09,150
type이 다른 variable의 value를

133
00:08:09,150 --> 00:08:13,410
다른 type의 variable에 assign하는 경우를 살펴 보겠습니다.

134
00:08:13,410 --> 00:08:15,870
myInt는 int type입니다.

135
00:08:15,870 --> 00:08:20,650
이 myInt의 value를 double type인 myDouble에 assign 하였습니다.

136
00:08:20,650 --> 00:08:24,930
이 떄 아무런 다른 장치 없이 그냥 assign을 해도 되는 것은

137
00:08:24,930 --> 00:08:29,450
double type의 data 범위가 int보다 훨씬 넓기 때문입니다.

138
00:08:29,450 --> 00:08:32,770
이런 방식을 implicit conversion이라 합니다.

139
00:08:32,770 --> 00:08:38,070
myInt의 value 10은 double로 assign 되면서 10.0 이 되었습니다.

140
00:08:38,070 --> 00:08:41,860
반면에 myDouble을 myInt로 assign하는 경우에는

141
00:08:41,860 --> 00:08:47,740
(Int) 라는 casting operator를 붙여 explicit conversion을 해 주어야 합니다.

142
00:08:47,740 --> 00:08:50,670
double에서 int로 casting 되었을 경우

143
00:08:50,670 --> 00:08:54,900
소숫점 이하 값은 버려지고 정수부분만 남게 됩니다.

144
00:08:54,900 --> 00:09:00,330
따라서 9.78이라는 double 값은 9라는 int값으로 변환됩니다.

145
00:09:00,330 --> 00:09:01,820
페이지 11

146
00:09:01,820 --> 00:09:06,760
Named constants는 특정한 value를 identifier로 나타내어

147
00:09:06,760 --> 00:09:08,950
그 의미를 명확히 하면서

148
00:09:08,950 --> 00:09:13,130
프로그램에서 숫자 대신 이름을 사용할 수 있도록 하는 것입니다.

149
00:09:13,130 --> 00:09:17,960
이 예에서는 INCHES_PER_FOOT 라는 value가 12로 정의되었는데

150
00:09:17,960 --> 00:09:21,930
1 foot가 12 inch라는 사실은 변하지 않기 때문에

151
00:09:21,930 --> 00:09:26,680
이 value를 constant, 즉, 상수로 놓을 수 있는 것입니다.

152
00:09:26,680 --> 00:09:29,680
RATE는 0.14로 고정되는데

153
00:09:29,680 --> 00:09:34,510
금리와 같은 어떤 특정 비율을 나타내는 것으로 예상할 수 있습니다.

154
00:09:34,510 --> 00:09:39,320
이와 같이 named constant는 한번 그 value가 정의되면

155
00:09:39,320 --> 00:09:42,740
프로그램 내에서 다시 value를 바꿀 수 없습니다.

156
00:09:42,740 --> 00:09:44,500
만일 바꾸려는 시도를 하면

157
00:09:44,500 --> 00:09:46,890
Compile error가 나게 됩니다.

158
00:09:46,890 --> 00:09:50,970
public static final 이라는 keyword들이 붙어 있는데

159
00:09:50,970 --> 00:09:54,420
여기서 final 의 의미가 constant를 나타내며

160
00:09:54,420 --> 00:09:57,790
값을 다시 바꿀 수 없다는 것을 나타냅니다.

161
00:09:57,790 --> 00:10:02,750
Naming constant를 나타내는 identifier의 이름을 지을 때

162
00:10:02,750 --> 00:10:05,050
일반적으로 대문자만을 사용하며,

163
00:10:05,050 --> 00:10:07,770
단어간에는 언더바 (_) 를 사용합니다.

164
00:10:07,770 --> 00:10:09,290
페이지 12

165
00:10:09,290 --> 00:10:14,830
String type은 Java가 제공하는 기본 package에 들어있는 class type 입니다.

166
00:10:14,830 --> 00:10:19,480
text string을 다루기 위해 사용되는 reference type입니다.

167
00:10:19,480 --> 00:10:23,760
세개의 String인 greeting, firstName, lastName들은

168
00:10:23,760 --> 00:10:27,840
각각 “Hello World!”, “John”, “Doe” 로 initialize되었습니다.

169
00:10:27,840 --> 00:10:31,470
String은 plus operator를 사용하여 서로 연결,

170
00:10:31,470 --> 00:10:34,550
즉, concatenation 될 수 있습니다.

171
00:10:34,550 --> 00:10:38,470
example에서 연결된 fullName String의 value가

172
00:10:38,470 --> 00:10:41,400
화면에 프린트 되는 것을 볼 수 있습니다.

173
00:10:41,400 --> 00:10:42,970
페이지 13

174
00:10:42,970 --> 00:10:47,620
String concatenation의 경우 String들 간의 연결 뿐 아니라

175
00:10:47,620 --> 00:10:52,190
이 프로그램 처럼 42와 같은 정수 literal을 연결하여

176
00:10:52,190 --> 00:10:54,780
하나의 String으로 만들 수 있습니다.

177
00:10:54,780 --> 00:11:00,400
또 int type k와 같이 primitive type이나 class type의 variable도

178
00:11:00,400 --> 00:11:02,700
concatenate할 수 있습니다.

179
00:11:02,700 --> 00:11:06,540
이것이 가능한 것에 대해서는 class를 학습하면서

180
00:11:06,540 --> 00:11:09,280
좀 더 자세히 알아보도록 하겠습니다.

181
00:11:09,280 --> 00:11:10,850
페이지 14

182
00:11:10,850 --> 00:11:15,790
String은 다른 면에서 본다면 character들이 모여 있는 것으로 볼 수 있습니다.

183
00:11:15,790 --> 00:11:20,440
그러나 String이 char type의 array (배열) 과 같다는 것은 아닙니다.

184
00:11:20,440 --> 00:11:24,460
C 나 C++에서는 이 두가지가 일치하지만

185
00:11:24,460 --> 00:11:27,050
Java의 String은 그렇지 않습니다.

186
00:11:27,050 --> 00:11:30,890
그럼에도 Java의 String을 이루고 있는 각 문자들에는

187
00:11:30,890 --> 00:11:32,980
index가 붙어 있습니다.

188
00:11:32,980 --> 00:11:38,200
0부터 시작하는 index는 뒤에서 볼 String의 여러 method들에서

189
00:11:38,200 --> 00:11:40,210
유용하게 이용됩니다.

190
00:11:40,210 --> 00:11:44,130
유의할 점은 빈칸 (blank space) 도

191
00:11:44,130 --> 00:11:47,060
하나의 character로 간주된다는 것입니다.

192
00:11:47,060 --> 00:11:48,580
페이지 15

193
00:11:48,580 --> 00:11:52,390
String class에는 여러가지의 method가 존재합니다.

194
00:11:52,390 --> 00:11:57,980
먼저 str String의 value가 “Hello, World!” 라 가정합시다.

195
00:11:57,980 --> 00:12:00,960
length() 는 String의 길이를 return합니다.

196
00:12:00,960 --> 00:12:03,830
앞 페이지의 index 측면에서 본다면

197
00:12:03,830 --> 00:12:08,140
String의 끝 문자의 index + 1 이 length와 같습니다.

198
00:12:08,140 --> 00:12:13,760
charAt(index)는 스트링에서 index 자리에 위치한 캐릭터를 return합니다

199
00:12:13,760 --> 00:12:18,850
이 예제에서 charAt(0)는 대문자 캐릭터 H를 리턴합니다

200
00:12:18,850 --> 00:12:23,450
substring(int) 는 String에서 주어진 parameter index 부터

201
00:12:23,450 --> 00:12:26,530
맨 끝까지의 부분 String을 return 합니다.

202
00:12:26,530 --> 00:12:29,640
“Hello, World!” 의 경우 substring(7) 은

203
00:12:29,640 --> 00:12:33,400
Index 7인 ‘W’ 부터 시작하여 끝까지 이니까

204
00:12:33,400 --> 00:12:35,390
“World!” 를 return 합니다.

205
00:12:35,390 --> 00:12:41,060
substring(0, 5)는 begin index 0부터 end index 5까지의

206
00:12:41,060 --> 00:12:43,360
부분 String을 return 합니다.

207
00:12:43,360 --> 00:12:47,020
equals(String other) 는 equals를 call한 String과

208
00:12:47,020 --> 00:12:50,340
Parameter other 의 내용이 같은지를 test하여

209
00:12:50,340 --> 00:12:52,950
true 또는 false를 return 합니다.

210
00:12:52,950 --> 00:12:56,500
equalsIgnoreCase는 equals와 같으나

211
00:12:56,500 --> 00:13:00,180
대소문자 구분없이 같다면 true를 return합니다.

212
00:13:00,180 --> 00:13:01,700
페이지 16

213
00:13:01,700 --> 00:13:06,300
str.compareTo(String other) 는 사전식 배열에 따라

214
00:13:06,300 --> 00:13:09,800
str이 other보다 더 작으면 마이너스 값을

215
00:13:09,800 --> 00:13:13,670
같으면 0을, 더 크면 플러스 값을 return 합니다.

216
00:13:13,670 --> 00:13:20,360
str.indexOf(“World”) 는 str String 내에 “World” 라는 substring이 있을 경우

217
00:13:20,360 --> 00:13:24,720
가장 첫번째 substring의 시작 index를 return 합니다.

218
00:13:24,720 --> 00:13:31,620
str.lastIndexOf(“o”) 는 str 내에 String “o” 라는 substring이 출현할 경우

219
00:13:31,620 --> 00:13:35,960
가장 마지막에 출현하는 “o” 의 시작 index를 return 합니다.

220
00:13:35,960 --> 00:13:41,680
str.contains(“Hello”) 는 str 내에 “Hello” substring 이 존재하면

221
00:13:41,680 --> 00:13:43,560
true를 return합니다.

222
00:13:43,560 --> 00:13:47,640
str.replace() 는 여러 가지의 version이 있는데

223
00:13:47,640 --> 00:13:51,400
str에 출현하는 character, substring 등을

224
00:13:51,400 --> 00:13:54,330
두번째 것으로 대치하는 역할을 합니다.

225
00:13:54,330 --> 00:13:59,010
str.toUpperCase() 는 str을 모두 대문자로

226
00:13:59,010 --> 00:14:04,810
str.toLowerCase() 는 str을 모두 소문자로 바꾸어 return 합니다.

227
00:14:04,810 --> 00:14:06,430
페이지 17

228
00:14:06,430 --> 00:14:13,460
str.trim() 은 String의 맨 앞과 맨 뒤에 존재하는 공백을 모두 없애는 역할을 합니다.

229
00:14:13,460 --> 00:14:19,600
이 method는 web과 같은 UI 에서 text input을 받을 때 편리하게 사용됩니다.

230
00:14:19,600 --> 00:14:27,570
String.join(a, b, c) 는 b, a, c 순서로 세 String을 concatenation합니다.

231
00:14:27,570 --> 00:14:35,720
String.valueOf(123) 은 정수 123을 String “123” 으로 바꾸어 return 합니다.

232
00:14:35,720 --> 00:14:40,660
마찬가지로 String.valueOf(true) 는 boolean value인 true를

233
00:14:40,660 --> 00:14:43,380
String “true” 로 만들어 return 합니다.

234
00:14:43,380 --> 00:14:49,600
str.startsWith(“Hello”) 는 str이 “Hello”로 시작하면 true를 return합니다.

235
00:14:49,600 --> 00:14:56,240
str.endsWith(“!”) 는 str이 “!”로 끝날 경우 true를 return합니다.

236
00:14:56,240 --> 00:15:02,770
str.isEmpty()는 str이 empty String일 경우 true를 return 합니다.

237
00:15:02,770 --> 00:15:04,340
페이지 18

238
00:15:04,340 --> 00:15:06,480
Escape Sequence는

239
00:15:06,480 --> 00:15:11,780
첫번째, 프로그램에서 특별한 의도로 사용되는 문자를 프린트하고 싶을때

240
00:15:11,780 --> 00:15:16,670
두번째, 눈에 안보이는 특수 문자를 프린트하고 싶을 때 사용합니다.

241
00:15:16,670 --> 00:15:22,730
Double quote, Single quote, Backslash 는 특별한 의도로 사용된 문자들이고

242
00:15:22,730 --> 00:15:27,930
New line, carriage return, tab 은 눈에 안보이는 특수 문자 입니다.

243
00:15:27,930 --> 00:15:32,530
이 example에서는 backslash, new line, double quote,

244
00:15:32,530 --> 00:15:37,750
Tab, single quote의 escape sequence를 사용하여 프린트 하였습니다.

245
00:15:37,750 --> 00:15:39,290
페이지 19

246
00:15:39,290 --> 00:15:44,800
Java String은 immutable 입니다, 즉, String의 내용은 바꿀 수 없습니다.

247
00:15:44,800 --> 00:15:50,160
내용을 바꾸고 싶다면 String 대신 StringBuffer object를 사용합니다.

248
00:15:50,160 --> 00:15:55,230
물론 String의 내용을 assignment를 이용하여 바꾸는 것은 가능합니다.

249
00:15:55,230 --> 00:15:59,280
이 예에서는 name의 내용을 “Soprano” 로 assign 했다가

250
00:15:59,280 --> 00:16:03,380
다시 “Anthony Soprano” 로 바꾸는 것을 보여주고 있습니다.

251
00:16:03,380 --> 00:16:08,450
엄밀히 말하면 이 경우 name에 원래 할당되었던 memory가 유지되면서

252
00:16:08,450 --> 00:16:11,480
그 memory의 내용이 바뀌는 것은 아닙니다.

253
00:16:11,480 --> 00:16:16,360
assignment를 새로 할 때마다 새로운 memory space가 할당되기 때문에

254
00:16:16,360 --> 00:16:20,930
String이 여전히 immutable하다는 원칙은 유지가 되는 것입니다.

255
00:16:20,930 --> 00:16:22,310
페이지 20

256
00:16:22,310 --> 00:16:27,950
ASCII character set은 기존의 컴퓨터 시스템에서 가장 많이 쓰이던 것입니다.

257
00:16:27,950 --> 00:16:32,780
이 character set에는 영어 키보드 자판에 있는 모든 문자들과

258
00:16:32,780 --> 00:16:35,810
일부 special character를 담고 있습니다.

259
00:16:35,810 --> 00:16:39,360
이 문자들이 모두 128개 이기 때문에

260
00:16:39,360 --> 00:16:43,120
ASCII set은 8bit로 충분히 나타낼 수 있습니다.

261
00:16:43,120 --> 00:16:45,210
이러한 판단에 근거하여

262
00:16:45,210 --> 00:16:48,190
Java 이전의 프로그래밍 언어들에서는

263
00:16:48,190 --> 00:16:54,330
Character type의 크기를 8bit (1 byte) 로 정의한 경우가 많았습니다.

264
00:16:54,330 --> 00:16:58,070
C, C++ 가 대표적인 경우 입니다.

265
00:16:58,070 --> 00:16:59,690
페이지 21

266
00:16:59,690 --> 00:17:02,980
그러나 8bit 만으로 영어 알파벳 이외에

267
00:17:02,980 --> 00:17:08,410
외국어 문자들이나 다양한 기호들을 모두 나타내는 것은 불가능하였기 때문에

268
00:17:08,410 --> 00:17:14,570
Java에서는 한 문자를 8bit가 아닌 16bit인 Unicode로 나타내게 되었습니다.

269
00:17:14,570 --> 00:17:17,370
따라서 여러분이 써 보면 아시겠지만

270
00:17:17,370 --> 00:17:22,590
Java 프로그램에서는 한글로 된 variable 이름과 같은 것도 가능합니다.

271
00:17:22,590 --> 00:17:27,550
물론 본 코스에서는 한글 variable 이름을 권장하지는 않습니다.
