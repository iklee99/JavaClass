I will lecture on Class and Object
Class is one of the most important OOP elements in Java
Simply put, programming in Java
means implementing classes, all code
must exist within a class,
and all new types created by the programmer are classes
So, what is the difference between a class and an object?
A class can be said to be a template that can create an object
For example, if the class is called a waffle maker,
the object can be said to be a waffle made with the waffle maker
Just as you can bake countless waffles with a single waffle maker,
you can create an infinite number of objects with a single class
So, what does "instance" mean? An instance is a single entity
embodied by a class, and can be seen as a term
with almost the same meaning as "object."
In practice, object and instance are used interchangeably
The Student class has two instance
variables: name, a String variable representing the
student's name, and id, an int variable representing the student ID
In the main method of the StudentDemo class, two objects of the Student class,
s1 and s2, are created
When creating an object, the new command is used
When the first instance of the Student class, s1, is created,
information about the class Student is created in the JVM's memory
Now, whenever an instance is created using the new command,
a separate memory is allocated for the instance, that is, the object
Because instances are separated into independent spaces in memory,
Different values can be assigned to the instance
variables of each instance
For example, the name of s1 can be “Tom”, the id of s1 can be 2305365,
the name of s2 can be “Jane”, and the id of s2 can be 2281686
When accessing instance
variables like this, use objectName variable
Now let's consider a class called SampleClass
SampleClass has an instance variable
of int type x and a method called sayHello
sayHello takes an int parameter
called y and concatenates the instance
variables x and y to print Hello x_value y_value
Let's organize the use of instance
variables and methods, which are members of a class
The new operator is used to create an object of a certain class
When reading the value of an instance
variable or assigning a value to an instance
variable, the dot operator (.) is used
The x value of Object c1 is assigned as 2, and the x value of Object
c2 is 3 because it is the x value of c1 plus 1
Similarly, when calling a method of an object,
the dot operator (.) is used
Since the x value of c1 is 2, it will print “Hello 2 5”
Similarly, c2.sayHello(7) will print “Hello 3
7” since y is 7 and x in c2 is 3
Let's consider SampleClass again
One more method called squareX has been added to this class
In the squareX() method, we first call sayHello(x+1) to print
"Hello x_value x_value + 1"
And it returns the square of x
But there is something a little strange
In the previous slide, we said that when accessing an instance variable
or calling a method,
we write the object name first and then use the dot operator
Here, we can see that the dot operator is not used when accessing x or calling sayHello
This is because x and sayHello are accessed within the same class, SampleClass
As in the previous slide, when accessing instance
variables or methods from outside the class they belong to,
you must use the dot operator
However, when using instance variables or methods within the same class,
you can use them without object and (.) operator
Now, let's look at a car rental system program as an example
This program consists of three classes: Car, Customer, and CarRentalSystem
First, the class Car contains information about the car
Instance variables include String variables representing the model name and license plate number
Below that, there is a totalCars variable of static int type
A static variable is also called a class variable
Unlike instance variables, this static variable exists only in the Car class
and is shared by all objects
That is, all objects of the Car class will have the same value
The static variable totalCars increases by 1 each time a Car object is created,
indicating the total number of cars at any given moment
COMPANY_NAME is the unique rental system company name in this system,
so it is defined as a named constant,
a static final String type, and initialized to "SuperCar Rentals."
The displayCarDetails() method prints the model
and license plate number of each Car object
The displayTotalCars() method is a static method that prints
the static variable totalCars
Since no instance variables are used in this method,
only the static variable totalCars is used,
so this method can be shared by all Car objects
These methods are called static methods,
and information about static methods
is also stored only in the class info of the Method area
We will study static members in more detail in Chapter 5
class Customer contains information about customers
who rent cars from this company
There are instance variables
representing the customer's name and customer number,
and displayCustomerDetails() is a method that displays
the Customer's information
The rentCar method accepts the parameter car of the Car class
and displays a message that the customer object
calling the rentCar method has rented a car
However, this program doesn't keep track
of which customer rented which car
The CarRentalSystem class creates Car and Customer objects,
displays their information, and sends a message to the customer
requesting a car rental
First, create a Car object called car1
We increase Car.totalCars, which we saw earlier, by one
to maintain the current number of Car objects
One thing to note is that instead of accessing the static variable totalCars
using a specific object like car1,
you can access it using the class name Car with the dot operator,
using capital letters Car dot totalCars
This is possible because totalCars is a static variable,
so there is only one of it in the Car class
Of course, you can also access it as car1.totalCars
In the same way, create another Car object called car2
And then call the displayCarDetails() method of each Car object to display
the car's information
It also shows the current totalCars value
Here we create two Customer objects
Assign each name and customer ID
And then we use the displayCustomerDetails() method to display
the Customer's information
And then it shows a message to two customers
that they are renting a car
Finally, it shows the name of this car rental company
This slide shows how multiple Java source files form
a single program
A source file contains only one class
The class name and the source file name must be the same
Class1 has public access, and Class2
has default (package) access
As long as all source files are in the same folder,
there's no difference between public and package permissions
We'll discuss access modifiers in more detail in Chapter 5
The AATest class has a main method
So, when you compile this program,
an executable file called AATest.class is generated
Here, objects of Class1 and Class2 are created, and the values 3 and 5 are assigned to the instance
variable a of each object, and the values 3 plus 1 and 5 minus 1 are displayed,
which are 4 and 4, respectively
AATest, the class that has the main method,
must have public permission
Typically, when coding in Java,
it is common to have only one class per source file
This way, you can easily guess the contents of the file since the source
file name directly refers to the class name
However, since our auto-judge
server only allows you to submit one source
file, you must write all classes in one source file
We will look at this case in the next slide
This slide demonstrates programming by
putting multiple classes into a single Java source file
In this case, only the class that has main should have public permission
Here, the AAATest class is public
Also, the name of the public class must be the name of the source file
All other classes should have package permissions
Here, Class3 and Class4 are like that
A local variable is a variable that is declared
and used within a method
Also, all method
parameters are considered local variables
For example, args, p, and q are local variables of main
b and c are local to the add method of Class3
Another b is local to the sub method of Class4
There are no global variables in Java
All classes must interact with other classes through appropriate parameters
and method calls
Although these strict rules can sometimes make programming difficult,
they have the advantage of preventing errors
that global variables can cause
Since a is a local variable in
ATest's main, it can be accessed from other blocks,
such as the for loop within the main method
k is a local variable of the for loop block,
so it is not visible outside the for loop
And since a, which is local to main, is visible within the for loop,
declaring another a within the for loop block is redundant,
so a compile error occurs the moment it is declared
On the other hand, accessing k is a compile error
because k is destroyed and no longer visible once the for loop is exited
The Venn diagram shows the scope of local variables
This slide shows a case where other methods are defined
and used within the same class
in addition to the main method
Ultimately, this is a case where another method is called
within the main method, and in this example,
MyMethod is called within main to find the sum of a, b, and c
However, since main is a static method,
only static methods or static variables can be used within main
That is, myMethod must also be a static method
Actual parameter is a term that refers to
the parameter passed when calling a method
In this example, in result
= myMethod(a,b,c) , a, b, and c are actual parameters
On the other hand, in the definition of myMethod(int d,
int e, int f), the parameters d, e, and f
that receive values are formal parameters
The name actual parameter refers to the value that is actually passed,
and the name formal parameter refers to the formal name that is passed
and used within the method
Meanwhile, the terms parameter and argument are actually used almost interchangeably,
although there is a subtle difference
In this example, the actual parameter c is of type int,
while the corresponding formal parameter f is of type double
At this time, c's int value is automatically converted to double type
This automatic conversion is possible because
the double type has a wider range of expressions than the int type
If we look at the range of expressions for this automatic conversion,
byte is the smallest at 1 byte, char is unsigned at 2 bytes,
and the range of expressions expands in the order of short, int, long, float, and double
This slide explores the special reference
value "this."
The referenceThis method of SomeClass simply prints
the value of this 
“this” refers to the reference to the object created in this class,
that is, the object’s address
In the main of the ThisRefTest class,
let’s directly print out the value of the “this” reference
First, o1 and o2 were created as objects of SomeClass
o3 has the same reference as o1 because o1 was assigned as is
First, if you print o1, it will say “SomeClass@6b95977”
Here, SomeClass indicates what class o1 is,
and 6b95977 is a reference to o1
Below, I tried calling the o1
dot referenceThis() method to print this
this has the same value as the reference of o1 right above
Similarly, we can see that this of o2
and o2 have exactly the same reference value
This reference can be conveniently used
when referring to an instance variable
Among the three formal parameters of the setMyDate method, month and day
have the same names as instance variables
The values of these formal parameters
are assigned to instance variables
Therefore, if the names of formal parameters are different
from those of instance variables, for example,
newMonth and newDay, they can be distinguished from instance
variables, but for semantic consistency,
it is more convenient
to make them the same as the names of instance variables
However, since the left and right sides of an assignment cannot have the same name,
there must be another way
In this case, using reference this can easily solve this problem
The reference this represents a reference to the object itself,
so this dot month
and this dot day mean instance variables
And if you just use month and day,
they mean formal parameters
When SomeClass is completely empty and has no methods,
two objects of this SomeClass, o1 and o2, are created, and o3 is assigned to o1
as is, so that it points to the same object as o1
When I ran o1.equals(o2) at this time, I got false
o2.equals(o3) also got false, and o3.equals(o1) got true
Even though the equals
method is not defined in SomeClass,
there is no compile error
This would mean that even though we don't explicitly define an equals method in SomeClass,
an equals method already exists, even though we can't see it
However, from the three prints, we can infer that the equals method returns
a boolean result of comparing the reference of the object
that calls equals with the object given as a parameter
That is, if you write the code for the equals method, it will be implemented as simply as this
In fact, the equals method already exists in every class,
although it is not visible
It is difficult to give a clear reason for this at this time
We will study the exact reason later when we learn inheritance
However, if we want to compare whether the contents of two objects are truly the same
rather than simply comparing references,
we need to redefine the equals method
In this example, SomeClass has two instance variables: name and x
We've redefined equals
so that it returns true only if both name
and x have the same value
To determine if name, which is a String type, is equal to other.name,
we simply use the equals method of the String class
The equals method of the String class is already well defined to return true
when the contents of two Strings are equal
If we redefine the equals method for every class we define,
it will be very convenient to use
Similar to equals, the toString method
already exists in every class
The purpose of toString is to return the contents of an object
(mainly the contents of instance variables) as a String
So it's a good idea to properly
redeine the toString method for each class
In this example, we first indicate that this object is an object of SomeClass,
and then add the two instance
variables, name and x value, to complete the String and return it
This example shows the practical use of equals and toString
First, the Student class has three instance variables: name, id, and age
The setData method assigns the name, id, and age
given as parameters to three instance variables
The equals method is redefined, so it returns true
only if name, id, and age are all equal
The toString method is designed to clearly display
the values of instance variables
In the EqualsToString class, three Student objects,
st1, st2, and st3,
were first created, and name, id, and age were assigned to each object
using the setData method
In println, “[st1] “ + st1 String was printed
When an object is passed as a parameter to println,
the toString method of that object is automatically executed
You can see that the String
returned by toString is printed in OUTPUT
Since the contents of st1 and st3
are the same, st1.equals(st3) returns true