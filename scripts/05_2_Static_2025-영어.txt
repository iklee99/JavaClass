05-2 I will lecture on Static
Let's learn about the difference between instance members and static members
An instance member is a member
that has a different value for each object
For example, if we consider the Student class of a specific middle school,
the member called
student's name can be said to be an instance member
Because each student can have a different name
A static member is a member
shared by all objects in a class
For example, if we consider the Student class of a specific middle school
as in the case above, the school name can be considered a static member
Because all students are students at the same specific middle school,
their school names are all the same
Let's recall the JVM's memory structure again
Here, static members are stored in the Method area
That is, because the things that exist uniquely in a class
and are shared by all objects of that class
are stored in the static area
of the Method area. Consider the Student class again
It has private instance variables id and name,
but since objects created from the Student class, that is,
students, can have different names and student numbers,
id and name must be instance members
Information about each created object,
especially the values of instance
variables, are stored separately in the heap area
On the other hand, schoolName and numStudent of the Student
class are static members
Assuming that it is a class for students who attend a specific school,
schoolName has the same value for all students
and the number of students at that school is also the same for all students
However, in this example, schoolName is defined as public static,
which can be changed, and numSudents is a named constant,
which can never be changed
These static members are stored in the Method area,
as seen in the previous slide
When accessing static variables, you can access them
using the class name without creating an object
In this example, we created two objects of the Student class, st1 and st2
We assigned the instance variables name of st1 and st2
to "John" and "Tom", respectively
Because name is a private variable, we used the mutator setName
And to read the name of st1,
we used the accessor method called st1.getName() to read the value
To access instance members like this, the general method is to create an object
and access it through the object dot operation
Again, this is because instance
members are different for each object
However, when accessing a static variable, there is no need to create an object
and you can use it like the class name dot
In this example, we accessed the class name Student
using Student dot schoolName 
This type of access is possible
because there is only one static member in a class
Now, let's look at the static
members of Java's representative built-in classes
The Math class provides several standard mathematical methods
The Math class belongs to the java.lang package,
so you can use it without importing it
All methods and data in the Math class are static
There are two predefined named constants:
Math.E holds the value of the base
e of the natural logarithm, and Math.PI holds the value of pi
This example shows how to find the area of a circle
The area of a circle is pi r^2, so it can be calculated as Math.PI * radius * radius
Below that, the Math.random() method returns a random real number
greater than or equal
to 0 and less than 1
The Math.random() method is a relatively simple method for generating random numbers
In this example, we are generating 10 random integers
in the closed interval 1 to 6
Basically, Math.random() returns a random real number
greater than or equal to 0 and less than 1
For example, a random real number like 0.366755 will appear
Now we use Math.random() inside a for loop
to generate 10 integers
But how can we convert a real number between 0 and 1 into an integer between 1 and 6?
First, Math.random() is a real number greater than or equal to 0 and less than 1
Multiplying this by 6 gives a real number greater than or equal to 0 and less than 6
Adding 1 to this will result in a real number greater than or equal to 1 and less than 7
Finally, if we convert this real number to an integer using (int), the random number will be one of the integers
1, 2, 3, 4, 5, or 6
In this way, it is necessary to determine the formula to be used to generate random real numbers
or integers in a specific range by examining them step by step
The 10 random integers obtained in this way are as follows:
Of course, the output will be different each time the program is run
This time, we'll look at a program
that flips a coin
and randomly produces heads or tails
In the main method of the CoinFlipDemo class,
we initialize the counter to 1 to use the while loop
Of course, you can use a for loop instead of a while loop
If you print “Flip number “ + counter and a colon
and then execute (int)(Math.random() * 2.0),
you will get a real number greater than or equal to 0 and less than 2
If you type convert this
using (int), you will get an integer 0 or 1
If it is 0, print “Heads”,
if it is 1, print “Tails”
And after increasing the counter by one, it goes back to the condition of the while loop and continues to repeat
as long as the counter is less than or equal to 5
Here is one example of the output from this program
Of course, this output may be different each time it is run
This time, we will use the java.util.Random class to generate
a random number
To do this, first,
I imported the Random class by doing “import java.util.Random”
The advantage of the Random class
is that it can use a seed of long integer type
Using a seed is especially convenient when debugging
a program that uses random numbers in the same order, because
as long as the same seed is used,
random numbers are generated in the same order
Here, we first set the seed to 365428
If you create a Random object with the default constructor,
you cannot use the seed
In this case, the random number does not know in what order
the numbers will come out in the future
Below that is a case where a random seed is provided
using a constructor that takes a seed as a parameter
Among the methods of the Random class,
nextInt() generates a random integer between the smallest possible
integer and the largest possible integer
nextInt(int n) generates a random integer
between 0 and n-1 when integer n is given as a parameter
So nextInt(3) + 4
will generate a random integer between 4 and 6
nextDouble() generates a random double number
greater than or equal to 0 and less than 1
In addition to this,
there are methods such as nextBoolean(), nextByte(),
nextFloat(), and nextLong() that randomly generate one of true or false
The setSeed(long) method is a method
that sets the seed of a Random object
Using the constructor called Random(seed)
and using the default constructor called Random()
and then immediately calling setSeed(seed)
have exactly the same behavior
Another useful method of the Math class is double pow(b, e),
which computes b raised to the power of e
abs() is a method that returns the absolute value
and is overloaded to allow use with int, float,
double, and long types
The min method returns the smaller of the two parameters
and is overloaded for int, long, float, and double types
The max method returns the larger of the two
round is overloaded for float and double types and returns
an integer rounded down to the nearest whole number
The double ceil(double d) method returns
the smallest integer greater than d as a double
That is, it is a “rounding up” operation
The double floor(double d) method returns
the largest integer less than d as a double type
That is, it is a “discard” operation
double sqrt(double d) returns the square root of d
Wrapper classes are also representative classes
belonging to the java.lang package
There is one wrapper class for each primitive type
Byte, Short, Integer, Long, Float,
Double, and Character are wrapper classes for byte, short,
int, long, float, double, and char types, respectively
These wrapper classes contain useful
predefined constants and static methods
Boxing refers to the ability to directly assign a primitive type
variable or literal to a corresponding wrapper class object
When a value of a primitive type is assigned,
it appears as if the value is automatically boxed and assigned to a wrapper class,
which is why it is called a boxing operation
If you look at the example code,
you can see that the value 5 is directly assigned to bObj,
which is a Byte wrapper object, 15 is directly assigned to sObj,
which is a Short wrapper object, and 256 is directly assigned to iObj,
which is an Integer wrapper object
On the other hand, if you want to convert
a wrapper class object to a value of the corresponding primitive type,
you must use the … Value() method of each wrapper class
That is, the primitive byte value
represented by bObj, a Byte wrapper object, is returned as bObj.bytevalue()
Similarly, if it is a Short wrapper object,
you should use methods such as sObj.shortValue(), intValue(),
longValue(), floatValue(), doubleValue(), and charValue() based on similar principles
However, even if you do not use the Value() method,
if you directly assign a Wrapper class
object to a primitive type
variable, automatic unboxing will occur
and appropriate values will be assigned to
the primitive variable
Among the useful constants in the wrapper classes, first of all,
there are the smallest number MIN_VALUE and the largest number MAX_VALUE
that each primitive type can represent
For example, Integer.MAX_VALUE, Double.MIN_VALUE, etc
Wrapper classes also have methods
that convert Strings to each primitive type value
For example, Integer.parseInt(“365”) returns
the int 365, and Double.parseDouble(“199.98”) returns the double 199.98
I assigned the string "673.23" to the string variable "theString",
but there are spaces before and after it
This happens a lot, especially when unnecessary spaces are entered
along with user input on the web
To remove leading and trailing spaces,
first use the String method trim() to remove unnecessary spaces
So now the value of trimedString will only be “673.23”
To convert this to double type,
you can call the wrapper class
Double.parseDouble(trimedString) to get the double value 673.23
Conversely, to convert a number to a String,
you can use the toString method of the wrapper class
For example, Double.toString(123.99) returns
the String “123.99”
The Character class, a wrapper class for the char type,
has useful static methods for handling characters
First, if you execute Character.toUpperCase(‘a’),
it returns the uppercase character ‘A’
Character.toLowerCase returns the opposite,
changing uppercase to lowercase
Character.isLowerCase(c) returns true if c is lowercase,
otherwise it returns false
Character.isWhiteSpace(c) returns true if c is a white space character
Here, white space characters refer to space, tab, line break, etc
Character.isLetter(c) returns true if c is an alphabet character
Character.isDigit(c) returns true if c is a numeric character
between ‘0’ and ‘9’
Character.isLetterDigit(c) returns true if isLetter(c) or isDigit(c) is true
That is, it returns true if c is an alphabetic character or a numeric character
This time, we will write
a program that uses the characteristics of static
variables to count
how many times all methods belonging to a class have been called
First, in class InvocationCounter,
the static int type numberOfInvocation was initialized to 0
This variable will store the number of times each method is called
When demoMethod() is called,
the static numberOfInvocation is increased by 1
Inside the outPutCount() method, numberOfInvocation is increased by 1
and the current value of numberOfInvocation is printed
In the static method
numberSoFar(), numberOfInvocation is also increased by 1
and the value is returned
Note that numberSoFar() can be made static
because no other instance variables are used inside it
In the main method,
we create an InvocationCounter object1
At this time, the value of InvocationCounter is initialized
to 0. Call object1.outPutCount()
At this time, invocationCounter increases by 1, so its value is now 1
outPutCount() prints this value and displays it
Now, object1.demoMethod() is called five times in a row
using a for loop, and with each call,
the value of invocationCounter increases by 1, becoming 6
The moment object1.outPutCount() is called, invocationCounter increases by 1 again,
becoming 7, and 7 is printed
Now we have created one more InvocationCounter object2
At this time, the static variable value is not initialized to 0
Because static variable is created when the class object is first created
That is, in this program, object1 is initialized only once
when it is created and is not initialized again after that
Since object2.demoMethod() and object2.outPutCount() are called 5 times consecutively
with the for loop,
the value of invocationCounter is now 17
In the last line,
when numberSoFar() is called, invocationCounter
is increased by 1 again and printed, so 18 is printed in the end
In this way, static variables are shared by all objects of that class
Therefore, it is useful for representing data
shared by multiple objects