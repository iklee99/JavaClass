1
00:00:00,000 --> 00:00:01,230
Page 1

2
00:00:01,230 --> 00:00:05,880
In this lecture, I will briefly introduce the Java language that will

3
00:00:05,880 --> 00:00:08,470
be used in this course

4
00:00:08,470 --> 00:00:09,670
Page 2

5
00:00:09,670 --> 00:00:14,320
First, I think it would be necessary to explain why

6
00:00:14,320 --> 00:00:16,570
we chose Java for our OOP course

7
00:00:16,570 --> 00:00:19,080
Java can be seen as a pure

8
00:00:19,080 --> 00:00:21,400
OO language itself

9
00:00:21,400 --> 00:00:24,720
Therefore, it is an ideal language for studying

10
00:00:24,720 --> 00:00:26,760
the main concepts of OOP

11
00:00:26,760 --> 00:00:31,640
For example, in a Java program,

12
00:00:31,640 --> 00:00:34,670
all variables and methods must belong to some class

13
00:00:34,670 --> 00:00:39,160
Code without a class cannot exist in Java

14
00:00:39,160 --> 00:00:42,240
If we look at this Java program,

15
00:00:42,240 --> 00:00:45,480
all the code is implemented within the class IdealOOP

16
00:00:45,480 --> 00:00:48,480
Therefore, Java programming can be said

17
00:00:48,480 --> 00:00:51,460
to be a continuous process of implementing classes

18
00:00:51,460 --> 00:00:52,740
Page 3

19
00:00:52,740 --> 00:00:56,190
Another reason we use Java in our course is that

20
00:00:56,190 --> 00:00:58,850
although it is an older language,

21
00:00:58,850 --> 00:01:02,380
it is still used in many places

22
00:01:02,380 --> 00:01:06,250
For example, it is widely used in large-scale enterprise system implementation,

23
00:01:06,250 --> 00:01:10,040
server implementations, the Android operating system is implemented in Java,

24
00:01:10,040 --> 00:01:13,440
and it is also widely used in implementing cloud systems

25
00:01:13,440 --> 00:01:14,720
Page 4

26
00:01:14,720 --> 00:01:17,230
This is the TIOBE index,

27
00:01:17,230 --> 00:01:20,470
which ranks programming languages

28
00:01:20,470 --> 00:01:22,460
based on how frequently they are used

29
00:01:22,460 --> 00:01:26,640
Here, Java, shown in orange,

30
00:01:26,640 --> 00:01:28,960
has been hovering between the 1st and 2nd

31
00:01:28,960 --> 00:01:32,460
place rankings since 2002 to the mid-2010s

32
00:01:32,460 --> 00:01:34,860
Python, shown in blue,

33
00:01:34,860 --> 00:01:39,670
began to make strides in the mid-2010s when Deep Learning emerged, and as of 2024,

34
00:01:39,670 --> 00:01:44,710
it is by far the top ranking

35
00:01:44,710 --> 00:01:49,880
Below that, we can see the traditionally used languages

36
00:01:49,880 --> 00:01:52,490
C, C++, and Java

37
00:01:52,490 --> 00:01:53,800
Page 5 Let's briefly introduce

38
00:01:53,800 --> 00:01:56,990
the history of the Java language,

39
00:01:56,990 --> 00:01:59,180
focusing on its application areas

40
00:01:59,180 --> 00:02:04,010
In the early 1990s, Java was developed by Sun Microsystems

41
00:02:04,010 --> 00:02:07,750
as a programming language for consumer electronics

42
00:02:07,750 --> 00:02:11,690
Java was officially released in 1995,

43
00:02:11,690 --> 00:02:15,190
and with the philosophy of "Write Once, Run Anywhere,"

44
00:02:15,190 --> 00:02:18,060
it was initially used primarily for developing applications

45
00:02:18,060 --> 00:02:21,610
that ran on the web, namely applets

46
00:02:21,610 --> 00:02:25,790
It began to be used gradually

47
00:02:25,790 --> 00:02:29,680
for corporate application development in the late 1990s

48
00:02:29,680 --> 00:02:33,860
and into the 2000s, and from the mid-2000s,

49
00:02:33,860 --> 00:02:36,160
it emerged as the main language for large-scale corporate system development

50
00:02:36,160 --> 00:02:37,440
Page 6 In the mid-2000s,

51
00:02:37,440 --> 00:02:42,120
it also began to be used in the field

52
00:02:42,120 --> 00:02:43,790
of mobile application development,

53
00:02:43,790 --> 00:02:45,960
and was widely used in the development of feature

54
00:02:45,960 --> 00:02:49,800
phone applications in the pre-smartphone era

55
00:02:49,800 --> 00:02:53,330
In the 2010s, the Android system was implemented in Java,

56
00:02:53,330 --> 00:02:56,830
establishing it as the main language

57
00:02:56,830 --> 00:02:59,550
for Android app development

58
00:02:59,550 --> 00:03:02,610
Java is still being used in various fields today,

59
00:03:02,610 --> 00:03:06,370
including web servers, enterprise systems,

60
00:03:06,370 --> 00:03:07,550
Android apps, Hadoop,

61
00:03:07,550 --> 00:03:10,870
a technology that processes large amounts of data

62
00:03:10,870 --> 00:03:14,530
by connecting multiple computers to process

63
00:03:14,530 --> 00:03:18,240
big data, and device control

64
00:03:18,240 --> 00:03:20,670
for the Internet of Things (IoT)

65
00:03:20,670 --> 00:03:22,030
Page 7 Java is expected to continue to be widely

66
00:03:22,030 --> 00:03:26,130
used in the future

67
00:03:26,130 --> 00:03:29,000
The Java language is expected to play a continued role in the development of various applications

68
00:03:29,000 --> 00:03:33,490
that run on the cloud,

69
00:03:33,490 --> 00:03:37,880
and its utilization in the fields of artificial intelligence and machine

70
00:03:37,880 --> 00:03:41,960
learning is gradually expanding

71
00:03:41,960 --> 00:03:46,270
Its importance in microservice architecture is expected to continue,

72
00:03:46,270 --> 00:03:48,570
so reusable classes that are in charge of detailed functions are gradually increasing,

73
00:03:48,570 --> 00:03:53,060
and its competitiveness is expected to continue through performance

74
00:03:53,060 --> 00:03:57,370
improvements and support for new hardware architectures

75
00:03:57,370 --> 00:04:01,520
along with the expansion of the Java ecosystem itself

76
00:04:01,520 --> 00:04:05,200
through interoperability with other JVM languages that compile to byte code (Kotlin, Scala, etc.)

77
00:04:05,200 --> 00:04:06,560
Page 8 Java is a cross-platform

78
00:04:06,560 --> 00:04:10,160
programming language

79
00:04:10,160 --> 00:04:13,870
“WORA”, or “Write Once Run

80
00:04:13,870 --> 00:04:17,030
Anyware”, is the acronym for this feature of Java

81
00:04:17,030 --> 00:04:20,480
To run a program written in the Java language,

82
00:04:20,480 --> 00:04:22,750
we compile it with the javac compiler,

83
00:04:22,750 --> 00:04:26,330
which produces a ".class" file that is expressed in "Byte Code",

84
00:04:26,330 --> 00:04:29,700
an intermediate language that is the same for all types

85
00:04:29,700 --> 00:04:31,890
of processors or operating systems

86
00:04:31,890 --> 00:04:36,120
These .class files run in a software virtual machine

87
00:04:36,120 --> 00:04:39,120
called the Java Virtual Machine (JVM)

88
00:04:39,120 --> 00:04:43,140
That is, byte code can be viewed as the machine

89
00:04:43,140 --> 00:04:44,730
language of the JVM

90
00:04:44,730 --> 00:04:48,830
Of course, JVM is a

91
00:04:48,830 --> 00:04:51,700
platform-dependent software that is implemented differently on each platform,

92
00:04:51,700 --> 00:04:55,640
but since byte code has a very simple format,

93
00:04:55,640 --> 00:04:59,820
the difficulty of implementing JVM is not that high

94
00:04:59,820 --> 00:05:01,180
Page 9

95
00:05:01,180 --> 00:05:04,180
This program is a simple program that adds the values of two integers

96
00:05:04,180 --> 00:05:09,270
a and b and prints them using a class called Add

97
00:05:09,270 --> 00:05:11,830
I will explain in more

98
00:05:11,830 --> 00:05:15,300
detail later, but in order for a class to run as a program,

99
00:05:15,300 --> 00:05:17,470
it must have a ‘main’ method,

100
00:05:17,470 --> 00:05:20,810
and the program will run from the main method

101
00:05:20,810 --> 00:05:23,580
First, assign the values 5 and 3 to two variables

102
00:05:23,580 --> 00:05:27,790
a and b of Integer type respectively

103
00:05:27,790 --> 00:05:31,060
Another integer type variable, result,

104
00:05:31,060 --> 00:05:33,910
will have the value of adding a and b,

105
00:05:33,910 --> 00:05:37,670
and the resulting value, result, will be printed on the screen

106
00:05:37,670 --> 00:05:38,950
Page 10

107
00:05:38,950 --> 00:05:43,600
The JVM has a simple stack machine architecture

108
00:05:43,600 --> 00:05:46,940
As we can see in the picture, input and

109
00:05:46,940 --> 00:05:49,340
output in Stack only occur in one direction

110
00:05:49,340 --> 00:05:54,280
When the stack is empty, the TOP index, which teaches the Stack Top, is -1, and when one data is pushed,

111
00:05:54,280 --> 00:05:57,410
it is stored in stack[TOP] and the

112
00:05:57,410 --> 00:05:59,890
TOP index is increased

113
00:05:59,890 --> 00:06:02,480
In this way, the push

114
00:06:02,480 --> 00:06:05,900
operation stacks new data one by one on

115
00:06:05,900 --> 00:06:08,170
top of the existing top element

116
00:06:08,170 --> 00:06:12,170
The pop operation removes the current top element

117
00:06:12,170 --> 00:06:14,830
and decreases the TOP index by one

118
00:06:14,830 --> 00:06:16,320
Page 11

119
00:06:16,320 --> 00:06:20,810
This program is an example of a Byte Code program

120
00:06:20,810 --> 00:06:24,550
obtained as output by compiling Java source code using javac

121
00:06:24,550 --> 00:06:28,180
Each line of Byte Code has a line number,

122
00:06:28,180 --> 00:06:32,050
and each line can be represented by only

123
00:06:32,050 --> 00:06:36,540
one byte (i.e. 8 bits or two hexadecimal digits)

124
00:06:36,540 --> 00:06:39,180
Before the Byte Code Program starts, the JVM's Variable array and Stack are initialized

125
00:06:39,180 --> 00:06:44,300
At Line 0, we encounter the bypush instruction (operation),

126
00:06:44,300 --> 00:06:48,190
which is an instruction to push the number of bytes

127
00:06:48,190 --> 00:06:51,900
(operand) immediately following it

128
00:06:51,900 --> 00:06:54,490
onto the stack

129
00:06:54,490 --> 00:06:58,770
The state of Variable memory and Stack after execution up to Line 1 is

130
00:06:58,770 --> 00:07:01,380
shown in the figure on the right

131
00:07:01,380 --> 00:07:05,090
As we can see in the picture, 5 is pushed onto

132
00:07:05,090 --> 00:07:07,620
the Stack, and the top index = 0

133
00:07:07,620 --> 00:07:11,170
In Line 2, the top element of the Stack is popped

134
00:07:11,170 --> 00:07:13,230
and stored in V{0]

135
00:07:13,230 --> 00:07:16,970
In Line 3, constant 3 is pushed onto the Stack

136
00:07:16,970 --> 00:07:20,520
In Line 4, the top element of the Stack is popped

137
00:07:20,520 --> 00:07:22,480
and stored in V[1]

138
00:07:22,480 --> 00:07:27,260
In Lines 5 and 6, V[0] and V[1] are pushed onto the Stack

139
00:07:27,260 --> 00:07:32,040
Line 7 pops two elements from the Stack, adds them, and

140
00:07:32,040 --> 00:07:34,500
then pushes the result back

141
00:07:34,500 --> 00:07:37,950
That is, here, 3 and 5 are popped,

142
00:07:37,950 --> 00:07:40,640
added, and the result, 8, is pushed

143
00:07:40,640 --> 00:07:44,190
In line 8, the top element of the Stack is popped

144
00:07:44,190 --> 00:07:46,180
and saved in V[2]

145
00:07:46,180 --> 00:07:52,210
Lines 9 to 12 display the result, V[2] = 8

146
00:07:52,210 --> 00:07:53,730
Page 12

147
00:07:53,730 --> 00:07:56,130
The byte code in the previous

148
00:07:56,130 --> 00:08:00,070
slide is executed in an interpreter called JVM

149
00:08:00,070 --> 00:08:02,790
The compiler first completely

150
00:08:02,790 --> 00:08:05,720
translates the source program into target code

151
00:08:05,720 --> 00:08:08,880
and saves it as an output target code file

152
00:08:08,880 --> 00:08:11,860
However, unlike a compiler, an

153
00:08:11,860 --> 00:08:15,130
interpreter executes commands one by one

154
00:08:15,130 --> 00:08:18,580
That is, it does not create an output file

155
00:08:18,580 --> 00:08:21,770
that has completed the translation like a compiler

156
00:08:21,770 --> 00:08:27,020
Since JVM is relatively simple, it can be implemented without difficulty

157
00:08:27,020 --> 00:08:30,860
Here we implemented JVM in Python

158
00:08:30,860 --> 00:08:32,770
This “main” part should

159
00:08:32,770 --> 00:08:35,800
actually be placed later in a Python program,

160
00:08:35,800 --> 00:08:39,540
but let’s look at it first for easier understanding

161
00:08:39,540 --> 00:08:43,720
To define the JVM's stack and variables as lists,

162
00:08:43,720 --> 00:08:46,570
their sizes were set to 100 each

163
00:08:46,570 --> 00:08:50,540
Stack pointer sp has an initial value of -1 and

164
00:08:50,540 --> 00:08:53,570
maintains the index of the current stack top

165
00:08:53,570 --> 00:08:56,160
And I initialized all the elements

166
00:08:56,160 --> 00:08:59,820
of the stack and variable list to 0

167
00:08:59,820 --> 00:09:01,390
Page 13 The bytecode program is stored as a list of two-digit

168
00:09:01,390 --> 00:09:04,580
hexadecimal numbers,

169
00:09:04,580 --> 00:09:08,550
as explained above

170
00:09:08,550 --> 00:09:13,640
These hexadecimal numbers are read in order, changing the state of

171
00:09:13,640 --> 00:09:17,190
the JVM and executing the program while interpreting it

172
00:09:17,190 --> 00:09:21,320
The function responsible for execution is jvm_execute

173
00:09:21,320 --> 00:09:25,840
After execution is complete, print the value of v[2] as the result

174
00:09:25,840 --> 00:09:27,410
Page 14 The jvm_push

175
00:09:27,410 --> 00:09:30,940
function is a function that pushes a

176
00:09:30,940 --> 00:09:33,400
given value onto the stack

177
00:09:33,400 --> 00:09:37,550
Increments the value of the current stack pointer (sp) and

178
00:09:37,550 --> 00:09:41,310
assigns a value to that index in the

179
00:09:41,310 --> 00:09:44,680
stack list The jvm_pop function returns the value of

180
00:09:44,680 --> 00:09:48,260
stack[sp], which is the top of the current stack,

181
00:09:48,260 --> 00:09:53,330
and decreases the value of sp, thereby decreasing the top index of the stack

182
00:09:53,330 --> 00:09:54,850
Page 15 The jvm_execute function receives a list

183
00:09:54,850 --> 00:10:00,180
of bytecode programs as a parameter, interprets

184
00:10:00,180 --> 00:10:04,020
the commands one byte at a

185
00:10:04,020 --> 00:10:06,210
time, and executes them

186
00:10:06,210 --> 00:10:11,330
The global variable sp refers to the JVM's stack

187
00:10:11,330 --> 00:10:15,090
pointer, and v is a variable array inside the JVM

188
00:10:15,090 --> 00:10:17,700
PC is an abbreviation for "program counter",

189
00:10:17,700 --> 00:10:22,920
and is an index used to read the bytecode program's instructions

190
00:10:22,920 --> 00:10:26,160
one by one, and increases as the program is read

191
00:10:26,160 --> 00:10:30,080
In the body of

192
00:10:30,080 --> 00:10:31,800
the while

193
00:10:31,800 --> 00:10:34,230
loop, each entry in the bytecode list is interpreted and the corresponding task is performed

194
00:10:34,230 --> 00:10:38,330
For example, 0x3c is the “istore_0” instruction, which moves

195
00:10:38,330 --> 00:10:42,720
the value at the top of the stack to v[0]

196
00:10:42,720 --> 00:10:46,950
The remaining commands were also explained in the previous slides

197
00:10:46,950 --> 00:10:51,390
Please take a look by following the bytecode program

198
00:10:51,390 --> 00:10:52,910
Page 16

199
00:10:52,910 --> 00:10:57,300
This table shows the differences between Compiler and Interpreter

200
00:10:57,300 --> 00:10:59,650
First, in terms of translation

201
00:10:59,650 --> 00:11:02,780
time, the compiler must finish compiling before

202
00:11:02,780 --> 00:11:05,030
the target code is executed

203
00:11:05,030 --> 00:11:07,690
However, the interpreter

204
00:11:07,690 --> 00:11:10,850
translates line-by-line during execution

205
00:11:10,850 --> 00:11:15,190
In terms of execution speed, the compiler is faster than the interpreter

206
00:11:15,190 --> 00:11:18,900
Since a compiler executes a program after translation is complete, it

207
00:11:18,900 --> 00:11:21,070
is significantly faster than an interpreter,

208
00:11:21,070 --> 00:11:25,330
which executes the program line by line

209
00:11:25,330 --> 00:11:28,490
When looking for errors, the

210
00:11:28,490 --> 00:11:33,040
compiler can find all errors that can be found at compile time,

211
00:11:33,040 --> 00:11:37,660
whereas the interpreter can only find errors in the

212
00:11:37,660 --> 00:11:39,330
line currently being executed

213
00:11:39,330 --> 00:11:42,200
In the case of the Compiler, an executable

214
00:11:42,200 --> 00:11:45,570
file is created, but since the Interpreter is executed

215
00:11:45,570 --> 00:11:48,180
line by line, an executable file is not created

216
00:11:48,180 --> 00:11:51,390
Representative languages that use

217
00:11:51,390 --> 00:11:56,540
compilers include C, C++, and Java (from source to bytecode)

218
00:11:56,540 --> 00:12:00,930
Representative interpreting languages include Java (bytecode

219
00:12:00,930 --> 00:12:04,510
execution), Python, JavaScript, and Ruby

220
00:12:04,510 --> 00:12:06,130
Page 17 If we look again

221
00:12:06,130 --> 00:12:09,160
at the execution process of a Java program, at compile time,

222
00:12:09,160 --> 00:12:12,140
the compiler translates the Java source

223
00:12:12,140 --> 00:12:16,220
code into a bytecode program

224
00:12:16,220 --> 00:12:19,980
This bytecode program is executed line by line

225
00:12:19,980 --> 00:12:22,980
by interpreting it within the Java Virtual Machine

226
00:12:22,980 --> 00:12:26,380
(JVM), which is implemented in software

227
00:12:26,380 --> 00:12:29,800
Because the interpreting process is relatively slow, various

228
00:12:29,800 --> 00:12:33,540
devices have been studied to compensate for the speed

229
00:12:33,540 --> 00:12:39,370
JVM has a device called JIT, or Just-In-Time

230
00:12:39,370 --> 00:12:42,770
Compiler, to speed up interpretation

231
00:12:42,770 --> 00:12:46,560
JIT compiles the byte code portions that are likely to

232
00:12:46,560 --> 00:12:51,030
appear frequently into the machine language of the actual computer on

233
00:12:51,030 --> 00:12:52,810
which the JVM is running

234
00:12:52,810 --> 00:12:56,810
Later, when the byte

235
00:12:56,810 --> 00:13:00,470
code part actually appears again,

236
00:13:00,470 --> 00:13:03,210
it is possible to quickly execute it by using a pre-compiled machine language version

237
00:13:03,210 --> 00:13:04,780
Page 18

238
00:13:04,780 --> 00:13:08,200
Now, let's summarize the features of the Java language

239
00:13:08,200 --> 00:13:11,390
First, Java is an object-oriented language with

240
00:13:11,390 --> 00:13:14,110
classes as its basic unit

241
00:13:14,110 --> 00:13:18,080
Additionally, the same source code can be executed

242
00:13:18,080 --> 00:13:23,100
regardless of the type of computer hardware or OS using the

243
00:13:23,100 --> 00:13:24,930
mechanism of bytecode and JVM

244
00:13:24,930 --> 00:13:28,640
This characteristic is called “platform independence.”

245
00:13:28,640 --> 00:13:31,170
The Java

246
00:13:31,170 --> 00:13:34,800
language automatically collects

247
00:13:34,800 --> 00:13:37,460
and reuses memory that is no longer being used during program execution

248
00:13:37,460 --> 00:13:41,040
This feature is called “automatic garbage collection.”

249
00:13:41,040 --> 00:13:46,420
This feature makes Java

250
00:13:46,420 --> 00:13:50,600
easy to learn, as it doesn't have complex pointers or dynamic memory management like in C++

251
00:13:50,600 --> 00:13:53,160
Because static typing is

252
00:13:53,160 --> 00:13:57,000
used, strict data type rules must be followed,

253
00:13:57,000 --> 00:14:00,840
which helps prevent programmer mistakes

254
00:14:00,840 --> 00:14:02,380
Java also

255
00:14:02,380 --> 00:14:07,060
has the ability to program jobs that are

256
00:14:07,060 --> 00:14:10,190
smaller than processes, called threads, to run concurrently

257
00:14:10,190 --> 00:14:13,140
Java provides excellent networking capabilities

258
00:14:13,140 --> 00:14:18,570
and, with JIT, overcomes the limitations of the interpreter, enabling fast execution

259
00:14:18,570 --> 00:14:23,320
As long as JVM is implemented,

260
00:14:23,320 --> 00:14:27,470
it can be easily run on new platforms, and many useful standard libraries are provided

261
00:14:27,470 --> 00:14:29,010
Page 19 To get a quick overview of the features of Java,

262
00:14:29,010 --> 00:14:31,830
let's look at the

263
00:14:31,830 --> 00:14:35,960
differences between the Java and Python languages

264
00:14:35,960 --> 00:14:38,620
First, if we look at the program structure,

265
00:14:38,620 --> 00:14:43,270
Python allows writing programs without using classes

266
00:14:43,270 --> 00:14:46,640
Of course, the Python language also has

267
00:14:46,640 --> 00:14:49,230
OOP concepts and can define classes,

268
00:14:49,230 --> 00:14:52,520
but it is not necessary to use classes

269
00:14:52,520 --> 00:14:55,860
However, in Java programs, everything must

270
00:14:55,860 --> 00:14:58,110
belong to a class

271
00:14:58,110 --> 00:15:03,670
In the case of this example program,

272
00:15:03,670 --> 00:15:06,150
a single class called PythonVSJava makes up the entire program

273
00:15:06,150 --> 00:15:07,530
Page 20 In terms of the type system,

274
00:15:07,530 --> 00:15:09,570
the type of

275
00:15:09,570 --> 00:15:13,620
a variable is not fixed in Python

276
00:15:13,620 --> 00:15:18,740
In this example, variable x becomes an “integer” type the moment the

277
00:15:18,740 --> 00:15:20,230
value 5 is assigned,

278
00:15:20,230 --> 00:15:23,210
and when “Hello” is assigned to x again, x

279
00:15:23,210 --> 00:15:26,060
changes to a String type

280
00:15:26,060 --> 00:15:30,710
However, such free type change is not possible in Java

281
00:15:30,710 --> 00:15:34,680
All variables have their types fixed before they are used,

282
00:15:34,680 --> 00:15:38,830
and the types of variables cannot be changed during program execution

283
00:15:38,830 --> 00:15:42,070
Also, in Python, there is no need

284
00:15:42,070 --> 00:15:46,410
to declare the type of a variable before using it

285
00:15:46,410 --> 00:15:50,460
However, in Java, a variable must be used after

286
00:15:50,460 --> 00:15:52,260
it has been declared

287
00:15:52,260 --> 00:15:53,880
Page 21 In Python,

288
00:15:53,880 --> 00:15:57,960
functions are defined using the “def” statement

289
00:15:57,960 --> 00:16:02,220
In Java, functions are implemented as methods belonging to a class

290
00:16:02,220 --> 00:16:03,870
Page 22 Python

291
00:16:03,870 --> 00:16:06,800
also has a class structure

292
00:16:06,800 --> 00:16:10,560
A class contains variables and functions

293
00:16:10,560 --> 00:16:13,930
In this example,

294
00:16:13,930 --> 00:16:16,440
variables called name

295
00:16:16,440 --> 00:16:20,250
and age are included in the class, and

296
00:16:20,250 --> 00:16:22,710
__init__ and say_hello are functions

297
00:16:22,710 --> 00:16:27,070
In particular, __init__ is a constructor that

298
00:16:27,070 --> 00:16:29,390
is automatically executed

299
00:16:29,390 --> 00:16:33,620
when a class object is created

300
00:16:33,620 --> 00:16:38,140
In Java, the entire program consists of one or more classes

301
00:16:38,140 --> 00:16:40,490
In this example, the

302
00:16:40,490 --> 00:16:44,040
class Person has two data, name and age,

303
00:16:44,040 --> 00:16:47,850
and has a constructor method Person and

304
00:16:47,850 --> 00:16:49,520
a sayHello() method

305
00:16:49,520 --> 00:16:51,240
Page 23 Python has a list structure

306
00:16:51,240 --> 00:16:56,360
that is similar to the concept of a traditional array

307
00:16:56,360 --> 00:16:59,390
The list structure is much more flexible than an array

308
00:16:59,390 --> 00:17:01,710
and has many features

309
00:17:01,710 --> 00:17:06,260
Java has a mechanism to create an array for each type

310
00:17:06,260 --> 00:17:10,490
Also, if we use a collection framework

311
00:17:10,490 --> 00:17:13,730
like ArrayList, we can use many more features

312
00:17:13,730 --> 00:17:15,380
For code blocks on page 24,

313
00:17:15,380 --> 00:17:19,870
Python expresses the same block with spaces

314
00:17:19,870 --> 00:17:23,030
without using any separate delimiters

315
00:17:23,030 --> 00:17:25,750
In the case of Java, the begin and

316
00:17:25,750 --> 00:17:28,880
end are clearly indicated with braces { }

317
00:17:28,880 --> 00:17:30,550
Page 25 In Python, the for loop performs

318
00:17:30,550 --> 00:17:34,990
repeated operations on the elements in

319
00:17:34,990 --> 00:17:37,550
a list

320
00:17:37,550 --> 00:17:41,830
In this example, we perform repeated operations on the fruits in the list

321
00:17:41,830 --> 00:17:47,110
called fruits and on the integers from 0 to 4

322
00:17:47,110 --> 00:17:52,230
Similarly, in Java, the for loop allows us to perform repeated

323
00:17:52,230 --> 00:17:55,290
operations on each element in an array

324
00:17:55,290 --> 00:17:59,370
Additionally, we can perform operations while incrementing

325
00:17:59,370 --> 00:18:02,190
the integer i from 0 to 4

326
00:18:02,190 --> 00:18:03,840
Page 26 Both Python and Java use interpretation,

327
00:18:03,840 --> 00:18:08,150
which inherently slows

328
00:18:08,150 --> 00:18:11,180
down program execution

329
00:18:11,180 --> 00:18:15,880
However, in the case of Java, mechanisms such

330
00:18:15,880 --> 00:18:18,680
as JIT can be used to make execution faster

331
00:18:18,680 --> 00:18:23,380
Python has a relatively simple syntax and is easy to learn

332
00:18:23,380 --> 00:18:27,190
In comparison, Java has a very strict grammar,

333
00:18:27,190 --> 00:18:30,270
which prevents programmers from writing

334
00:18:30,270 --> 00:18:34,450
programs that contain errors without realizing it

335
00:18:34,450 --> 00:18:40,090
Python includes library functions that are widely used in

336
00:18:40,090 --> 00:18:41,680
science and engineering,

337
00:18:41,680 --> 00:18:46,070
while Java has a rich standard library provided by default

338
00:18:46,070 --> 00:18:51,010
and many third-party libraries for enterprise applications

339
00:18:51,010 --> 00:18:56,550
Therefore, Python is widely used for

340
00:18:56,550 --> 00:19:00,210
prototyping, data analysis, machine learning, etc

341
00:19:00,210 --> 00:19:03,160
in research fields where execution speed is not important, and

342
00:19:03,160 --> 00:19:07,100
Java is widely used for corporate solutions such as server implementation,

343
00:19:07,100 --> 00:19:09,140
cloud implementation, Android application implementation, etc
