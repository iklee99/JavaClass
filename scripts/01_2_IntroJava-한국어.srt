1
00:00:00,000 --> 00:00:01,230
페이지 1

2
00:00:01,230 --> 00:00:05,880
이번 강의에서는 이번 코스에서 사용하게 될 Java 언어에 대해

3
00:00:05,880 --> 00:00:08,470
간단하게 소개하도록 하겠습니다.

4
00:00:08,470 --> 00:00:09,670
페이지 2

5
00:00:09,670 --> 00:00:14,320
먼저 왜 우리의 OOP 과목에서 Java를 선택하였는가에 대해

6
00:00:14,320 --> 00:00:16,570
설명이 필요할 것 같습니다.

7
00:00:16,570 --> 00:00:19,080
Java는 순수한 OO language

8
00:00:19,080 --> 00:00:21,400
그 자체라고 볼 수 있습니다.

9
00:00:21,400 --> 00:00:24,720
때문에 OOP의 주요 concept들을 공부하기에

10
00:00:24,720 --> 00:00:26,760
이상적인 언어 입니다.

11
00:00:26,760 --> 00:00:31,640
예를 들면 Java 프로그램에서는 모든 변수나 method들이

12
00:00:31,640 --> 00:00:34,670
반드시 어떤 class 안에 속해야 합니다.

13
00:00:34,670 --> 00:00:39,160
소속 class가 없는 code는 Java에서는 존재할 수 없습니다.

14
00:00:39,160 --> 00:00:42,240
이 Java 프로그램을 보아도 모든 코드는

15
00:00:42,240 --> 00:00:45,480
class IdealOOP 안에 구현되고 있습니다.

16
00:00:45,480 --> 00:00:48,480
따라서 Java 프로그래밍은 class들을

17
00:00:48,480 --> 00:00:51,460
계속 구현해 나가는 것이라 할 수 있습니다.

18
00:00:51,460 --> 00:00:52,740
페이지 3

19
00:00:52,740 --> 00:00:56,190
우리 course에서 Java를 사용하는 또 다른 이유는

20
00:00:56,190 --> 00:00:58,850
Java가 오래된 언어이기는 하지만

21
00:00:58,850 --> 00:01:02,380
아직도 많은 곳에 사용되고 있다는 점 때문입니다.

22
00:01:02,380 --> 00:01:06,250
예를 들면 대규모 기업 시스템 구현, 서버 구현,

23
00:01:06,250 --> 00:01:10,040
Android operating system이 Java로 구현되어 있고,

24
00:01:10,040 --> 00:01:13,440
클라우드 시스템의 구현에도 많이 사용됩니다.

25
00:01:13,440 --> 00:01:14,720
페이지 4

26
00:01:14,720 --> 00:01:17,230
이것은 programming language들이

27
00:01:17,230 --> 00:01:20,470
얼마나 사용되는지에 따른 ranking을 보여주는

28
00:01:20,470 --> 00:01:22,460
TIOBE index 입니다.

29
00:01:22,460 --> 00:01:26,640
여기서 2002년부터 2010년대 중반까지

30
00:01:26,640 --> 00:01:28,960
주황색으로 표시된 Java는

31
00:01:28,960 --> 00:01:32,460
거의 ranking 1, 2위를 넘나들고 있습니다.

32
00:01:32,460 --> 00:01:34,860
하늘색으로 표시된 Python이

33
00:01:34,860 --> 00:01:39,670
Deep learning이 출현한 2010년대 중반부터 약진하기 시작하여,

34
00:01:39,670 --> 00:01:44,710
2024년 현재,  단연 랭킹 1위를 차지하고 있습니다.

35
00:01:44,710 --> 00:01:49,880
그 아래로 전통적으로 많이 쓰이던 C, C++, Java가

36
00:01:49,880 --> 00:01:52,490
뒤따르고 있는 것을 볼 수 있습니다.

37
00:01:52,490 --> 00:01:53,800
페이지 5

38
00:01:53,800 --> 00:01:56,990
Java 언어의 역사를 응용 분야 중심으로

39
00:01:56,990 --> 00:01:59,180
간략히 소개해 보겠습니다.

40
00:01:59,180 --> 00:02:04,010
1990년대 초반 Java는 Sun Microsystems에서

41
00:02:04,010 --> 00:02:07,750
가전제품용 프로그래밍 언어로 개발 되었습니다.

42
00:02:07,750 --> 00:02:11,690
1995년에 Java가 공식적으로  발표되는데,

43
00:02:11,690 --> 00:02:15,190
"Write Once, Run Anywhere" 라는 철학을 가지고,

44
00:02:15,190 --> 00:02:18,060
초기에는 웹에서 구동되는 어플리케이션,

45
00:02:18,060 --> 00:02:21,610
즉, applet의 개발에 주로 사용되었습니다.

46
00:02:21,610 --> 00:02:25,790
1990년대 후반부터 2000년대 들어서

47
00:02:25,790 --> 00:02:29,680
차츰 기업 애플리케이션 개발에  사용되기 시작하였으며,

48
00:02:29,680 --> 00:02:33,860
2000년대 중반 부터는 대규모 기업 시스템 개발의

49
00:02:33,860 --> 00:02:36,160
주력 언어로 부상하였습니다.

50
00:02:36,160 --> 00:02:37,440
페이지 6

51
00:02:37,440 --> 00:02:42,120
2000년대 중반에는 또한 모바일 애플리케이션 개발 분야에

52
00:02:42,120 --> 00:02:43,790
이용되기 시작하였으며,

53
00:02:43,790 --> 00:02:45,960
스마트 폰 이전 시대인

54
00:02:45,960 --> 00:02:49,800
피처폰 애플리케이션 개발에 많이 사용되었습니다.

55
00:02:49,800 --> 00:02:53,330
2010년대에 들어서는 안드로이드 시스템이

56
00:02:53,330 --> 00:02:56,830
Java로 구현되면서, 안드로이드 앱 개발의

57
00:02:56,830 --> 00:02:59,550
주요 언어로 자리매김하게 됩니다.

58
00:02:59,550 --> 00:03:02,610
Java는 현재까지도 다양한 분야에서

59
00:03:02,610 --> 00:03:06,370
활용되고 있는데, 웹 서버, 엔터프라이즈 시스템,

60
00:03:06,370 --> 00:03:07,550
안드로이드 앱,

61
00:03:07,550 --> 00:03:10,870
빅데이터 처리를 위해 여러 개의 컴퓨터들을

62
00:03:10,870 --> 00:03:14,530
하나로 묶어 대용량 데이터를 처리하는 기술인 Hadoop,

63
00:03:14,530 --> 00:03:18,240
Internet of Things (IOT)의  디바이스 컨트롤

64
00:03:18,240 --> 00:03:20,670
등이 대표적인 분야들 입니다.

65
00:03:20,670 --> 00:03:22,030
페이지 7

66
00:03:22,030 --> 00:03:26,130
Java는 앞으로도 계속 많이 사용될 것으로 예측됩니다.

67
00:03:26,130 --> 00:03:29,000
Java 언어는 클라우드에서 실행되는

68
00:03:29,000 --> 00:03:33,490
다양한 애플리케이션 개발에서의 지속적인 역할이 기대되고,

69
00:03:33,490 --> 00:03:37,880
인공지능, 머신러닝 분야에서의 활용이 점차 확대되며,

70
00:03:37,880 --> 00:03:41,960
마이크로서비스 아키텍처에서의 중요성이 계속 유지되어,

71
00:03:41,960 --> 00:03:46,270
세부 기능을 담당하는 reusable class들이 점차 증가되고,

72
00:03:46,270 --> 00:03:48,570
Byte code로 compile되는

73
00:03:48,570 --> 00:03:53,060
다른 JVM 언어들 (Kotlin, Scala 등) 과의

74
00:03:53,060 --> 00:03:57,370
상호운용성을 통해 Java 생태계 자체의 확장과 함께

75
00:03:57,370 --> 00:04:01,520
성능 개선 및 새로운 하드웨어 아키텍처 지원을 통해

76
00:04:01,520 --> 00:04:05,200
계속적으로 경쟁력이 유지될 것으로 예상됩니다.

77
00:04:05,200 --> 00:04:06,560
페이지 8

78
00:04:06,560 --> 00:04:10,160
Java는 크로스 플랫폼 프로그래밍 언어입니다.

79
00:04:10,160 --> 00:04:13,870
"WORA”, 즉, “Write Once Run Anyware” 는

80
00:04:13,870 --> 00:04:17,030
Java의 이러한 특징을 일컫는 말 입니다.

81
00:04:17,030 --> 00:04:20,480
Java 언어로 작성된 프로그램을 실행하기 위해서는,

82
00:04:20,480 --> 00:04:22,750
javac 컴파일러로 컴파일하여,

83
00:04:22,750 --> 00:04:26,330
모든 유형의 프로세서 또는 운영 체제에 대해

84
00:04:26,330 --> 00:04:29,700
동일한 중간 언어인 "Byte Code"로 표현되는

85
00:04:29,700 --> 00:04:31,890
".class" 파일을 얻습니다.

86
00:04:31,890 --> 00:04:36,120
이 .class 파일은 JVM (Java Virtual Machine)이라는

87
00:04:36,120 --> 00:04:39,120
소프트웨어 가상 머신에서 실행됩니다.

88
00:04:39,120 --> 00:04:43,140
즉, 바이트 코드는 JVM의 machine language로

89
00:04:43,140 --> 00:04:44,730
볼 수 있습니다.

90
00:04:44,730 --> 00:04:48,830
물론 JVM은 다른 플랫폼마다 다르게 구현된

91
00:04:48,830 --> 00:04:51,700
platform-dependent 소프트웨어이지만,

92
00:04:51,700 --> 00:04:55,640
바이트 코드는 매우 간단한 형식을 가지고 있기 때문에

93
00:04:55,640 --> 00:04:59,820
JVM을 구현하는 난이도가 많이 높은 것은 아닙니다.

94
00:04:59,820 --> 00:05:01,180
페이지 9

95
00:05:01,180 --> 00:05:04,180
이 프로그램은 Add 라는 class로서

96
00:05:04,180 --> 00:05:09,270
두 정수 a, b의 값을 더하여 출력하는 간단한 프로그램입니다.

97
00:05:09,270 --> 00:05:11,830
나중에 더 자세히 설명하겠지만

98
00:05:11,830 --> 00:05:15,300
class가 하나의 프로그램으로 실행되기 위해서는

99
00:05:15,300 --> 00:05:17,470
‘main’ method를 가져야 하고

100
00:05:17,470 --> 00:05:20,810
main method 부터 프로그램이 실행되게 됩니다.

101
00:05:20,810 --> 00:05:23,580
먼저 Integer type의 두 variable

102
00:05:23,580 --> 00:05:27,790
a와 b에 각각 5와 3 이라는 값을 assign 합니다.

103
00:05:27,790 --> 00:05:31,060
또다른 integer type variable인 result는

104
00:05:31,060 --> 00:05:33,910
a와 b를 더한 값을 가지게 되고

105
00:05:33,910 --> 00:05:37,670
결과 값인 result를 screen에 출력하게 됩니다.

106
00:05:37,670 --> 00:05:38,950
페이지 10

107
00:05:38,950 --> 00:05:43,600
JVM은 간단한 Stack machine architecture를 가지고 있습니다.

108
00:05:43,600 --> 00:05:46,940
그림에서 보듯 Stack에는 input과 output이

109
00:05:46,940 --> 00:05:49,340
한 방향에서만 이루어 집니다.

110
00:05:49,340 --> 00:05:54,280
Empty stack일 때 Stack Top을 가르치는 TOP index는 -1이고,

111
00:05:54,280 --> 00:05:57,410
data 하나를 push하면 stack[TOP] 에 저장되며,

112
00:05:57,410 --> 00:05:59,890
TOP index를 증가시킵니다.

113
00:05:59,890 --> 00:06:02,480
이런 식으로 push operation은

114
00:06:02,480 --> 00:06:05,900
기존의 Top element 위에 새로운 data를

115
00:06:05,900 --> 00:06:08,170
하나씩 쌓아 나가게 됩니다.

116
00:06:08,170 --> 00:06:12,170
Pop operation은 현재의 Top element를 꺼내고

117
00:06:12,170 --> 00:06:14,830
TOP index를 하나 감소 시킵니다.

118
00:06:14,830 --> 00:06:16,320
페이지 11

119
00:06:16,320 --> 00:06:20,810
이 프로그램은 Java source code를 javac를 통해 컴파일하여

120
00:06:20,810 --> 00:06:24,550
그 출력으로 얻은 Byte Code 프로그램의 한 예입니다.

121
00:06:24,550 --> 00:06:28,180
Byte Code의 각 line에는 line number가 붙어 있으며,

122
00:06:28,180 --> 00:06:32,050
모든 line은 단 하나의 byte (즉, 8bits

123
00:06:32,050 --> 00:06:36,540
또는 두 개의 16진수 digits) 로만 표시될 수 있습니다.

124
00:06:36,540 --> 00:06:39,180
Byte Code Program의 시작 전에

125
00:06:39,180 --> 00:06:44,300
JVM의 Variable array와 Stack은 initialize 되어 있습니다.

126
00:06:44,300 --> 00:06:48,190
Line 0에서 bypush 명령 (operation) 을 만나는데,

127
00:06:48,190 --> 00:06:51,900
이 명령은 바로 뒤 byte의 수 (operand)를

128
00:06:51,900 --> 00:06:54,490
stack에 push하라는 명령입니다.

129
00:06:54,490 --> 00:06:58,770
Line 1까지 실행 한 후 Variable memory와 Stack의 상태를

130
00:06:58,770 --> 00:07:01,380
오른쪽 그림에서 보여주고 있습니다.

131
00:07:01,380 --> 00:07:05,090
그림에서 볼 수 있듯, Stack에는 5가 push되어 있으며,

132
00:07:05,090 --> 00:07:07,620
top index = 0 입니다.

133
00:07:07,620 --> 00:07:11,170
Line 2에서는 Stack의 top element를 pop하여

134
00:07:11,170 --> 00:07:13,230
V{0]에 저장합니다.

135
00:07:13,230 --> 00:07:16,970
Line 3에서는 constant 3을 stack에 push합니다.

136
00:07:16,970 --> 00:07:20,520
Line 4에서는 Stack의 top element를 pop하여

137
00:07:20,520 --> 00:07:22,480
V[1]에 저장합니다.

138
00:07:22,480 --> 00:07:27,260
Line 5, 6에서는 V[0]와 V[1]을 Stack에 push합니다.

139
00:07:27,260 --> 00:07:32,040
Line 7에서는 Stack에서 두 개의 element를 pop하여 이를 더한 후

140
00:07:32,040 --> 00:07:34,500
그 결과를 다시 push합니다.

141
00:07:34,500 --> 00:07:37,950
즉, 여기서는 3과 5를 pop하여 더한 후,

142
00:07:37,950 --> 00:07:40,640
그  결과인 8을 push하게 됩니다.

143
00:07:40,640 --> 00:07:44,190
Line 8에서는 Stack의 top element를 pop하여

144
00:07:44,190 --> 00:07:46,180
V[2]에  save합니다.

145
00:07:46,180 --> 00:07:52,210
Line 9 부터 12까지는 결과인 V[2] = 8을 display하는 부분입니다.

146
00:07:52,210 --> 00:07:53,730
페이지 12

147
00:07:53,730 --> 00:07:56,130
앞 슬라이드의 Byte Code는

148
00:07:56,130 --> 00:08:00,070
JVM이라 불리는 interpreter에서 실행됩니다.

149
00:08:00,070 --> 00:08:02,790
Compiler는 일단 source program을

150
00:08:02,790 --> 00:08:05,720
target code로 완전히 translate하여

151
00:08:05,720 --> 00:08:08,880
output target code file로 저장해 줍니다.

152
00:08:08,880 --> 00:08:11,860
그러나 Interpreter는 compiler와 달리

153
00:08:11,860 --> 00:08:15,130
command를 하나씩 바로 바로 실행해 나갑니다.

154
00:08:15,130 --> 00:08:18,580
즉, compiler 처럼 translation을 마친

155
00:08:18,580 --> 00:08:21,770
output file을 만들지 않는다는 것입니다.

156
00:08:21,770 --> 00:08:27,020
JVM은 비교적 단순하기 때문에 어렵지 않게 구현할 수 있습니다.

157
00:08:27,020 --> 00:08:30,860
여기서는 Python으로 JVM을 구현해 보았습니다.

158
00:08:30,860 --> 00:08:32,770
이 “main” part는 사실

159
00:08:32,770 --> 00:08:35,800
Python 프로그램에서 뒤 쪽에 위치해야 하지만,

160
00:08:35,800 --> 00:08:39,540
이해를 쉽게하기 위해 먼저 살펴 보도록 하겠습니다.

161
00:08:39,540 --> 00:08:43,720
JVM의 stack과 variable을 list로 정의하기 위해

162
00:08:43,720 --> 00:08:46,570
그 size를 각각 100으로 잡았습니다.

163
00:08:46,570 --> 00:08:50,540
Stack pointer sp는 초기값을 -1로 하는데,

164
00:08:50,540 --> 00:08:53,570
현재 stack top의 index를 유지합니다.

165
00:08:53,570 --> 00:08:56,160
그리고 stack과 variable list의

166
00:08:56,160 --> 00:08:59,820
element들을 모두 0으로 초기화 했습니다.

167
00:08:59,820 --> 00:09:01,390
페이지 13

168
00:09:01,390 --> 00:09:04,580
Bytecode program은 앞에서 설명한 것처럼,

169
00:09:04,580 --> 00:09:08,550
두 자리수 16진수의 list로 저장되어 있습니다.

170
00:09:08,550 --> 00:09:13,640
이 16진수들을 순서대로 읽어 JVM의 상태를 바꾸며

171
00:09:13,640 --> 00:09:17,190
프로그램을 interpreting하면서 실행하게 됩니다.

172
00:09:17,190 --> 00:09:21,320
실행을 담당하는 function이 jvm_execute입니다.

173
00:09:21,320 --> 00:09:25,840
실행이 다 끝난 후, v[2]의 value를 결과로 print합니다.

174
00:09:25,840 --> 00:09:27,410
페이지 14

175
00:09:27,410 --> 00:09:30,940
jvm_push function은 주어진 value를

176
00:09:30,940 --> 00:09:33,400
stack에 push하는 function입니다.

177
00:09:33,400 --> 00:09:37,550
현재 stack pointer (sp) 의 값을 하나 증가시키고

178
00:09:37,550 --> 00:09:41,310
stack list의 그 인덱스에 value를 assign합니다.

179
00:09:41,310 --> 00:09:44,680
jvm_pop function은 현재 stack의 top,

180
00:09:44,680 --> 00:09:48,260
즉, stack[sp] 의 value를 return하면서

181
00:09:48,260 --> 00:09:53,330
sp의 값을 감소시켜 stack의 top index를 하나 감소 시킵니다.

182
00:09:53,330 --> 00:09:54,850
페이지 15

183
00:09:54,850 --> 00:10:00,180
jvm_execute 함수는 bytecode 프로그램이 저장된 list를

184
00:10:00,180 --> 00:10:04,020
parameter로 받아서 한 byte씩 명령을 해석하고

185
00:10:04,020 --> 00:10:06,210
이를 실행하는 일을 합니다.

186
00:10:06,210 --> 00:10:11,330
Global variable인 sp는 JVM의 stack pointer를 말하며

187
00:10:11,330 --> 00:10:15,090
v는  JVM 내부의 variable array 입니다.

188
00:10:15,090 --> 00:10:17,700
pc는 “program counter” 의 약자인데,

189
00:10:17,700 --> 00:10:22,920
bytecode 프로그램의 명령들을 하나씩 읽어나가기 위한 index로서

190
00:10:22,920 --> 00:10:26,160
프로그램을 읽어나가면서 증가하게 됩니다.

191
00:10:26,160 --> 00:10:30,080
While 문의 body에서 bytecode list의 entry들을

192
00:10:30,080 --> 00:10:31,800
하나씩 해석하고

193
00:10:31,800 --> 00:10:34,230
그에 맞는 작업을 수행합니다.

194
00:10:34,230 --> 00:10:38,330
예를 들어 0x3c는 “istore_0” 명령인데,

195
00:10:38,330 --> 00:10:42,720
stack top에 있는 값을 v[0]로 옮기는 일을 하는 것입니다.

196
00:10:42,720 --> 00:10:46,950
나머지 명령들도 이전 슬라이드에서 설명했었습니다.

197
00:10:46,950 --> 00:10:51,390
한번 bytecode 프로그램을 따라가면서 확인해 보시기 바랍니다.

198
00:10:51,390 --> 00:10:52,910
페이지 16

199
00:10:52,910 --> 00:10:57,300
이 표는 Compiler와 Interpreter의 차이를 나타내고 있습니다.

200
00:10:57,300 --> 00:10:59,650
먼저 translation 시점 면으로,

201
00:10:59,650 --> 00:11:02,780
compiler는 target code가 실행되기 전에

202
00:11:02,780 --> 00:11:05,030
compile이 다 끝나야 합니다.

203
00:11:05,030 --> 00:11:07,690
하지만 interpreter는 실행 중에

204
00:11:07,690 --> 00:11:10,850
line-by-line으로 translation이 됩니다.

205
00:11:10,850 --> 00:11:15,190
실행 속도 면에서는 compiler가 interpreter보다 빠릅니다.

206
00:11:15,190 --> 00:11:18,900
compiler는 일단 translation이 다 끝난 후

207
00:11:18,900 --> 00:11:21,070
프로그램을 실행하기 때문에

208
00:11:21,070 --> 00:11:25,330
한 라인씩 실행하는 interpreter보다는 확연히 빠릅니다.

209
00:11:25,330 --> 00:11:28,490
Error를 찾는 시점은 compiler의 경우

210
00:11:28,490 --> 00:11:33,040
compile time에 찾을 수 있는 error들을 모두 찾아내는 반면

211
00:11:33,040 --> 00:11:37,660
interpreter의 경우는 현재 실행하고 있는 line에서의 error만

212
00:11:37,660 --> 00:11:39,330
찾을 수 있습니다.

213
00:11:39,330 --> 00:11:42,200
Compiler의 경우 실행 파일이 생기지만,

214
00:11:42,200 --> 00:11:45,570
Interpreter는 한 라인씩 실행되기 때문에

215
00:11:45,570 --> 00:11:48,180
실행 파일이 만들어 지지 않습니다.

216
00:11:48,180 --> 00:11:51,390
Compiler를 사용하는 언어로는 대표적으로

217
00:11:51,390 --> 00:11:56,540
C, C++, Java (from source to bytecode) 가 있습니다.

218
00:11:56,540 --> 00:12:00,930
Interpreting 언어로 대표적인 것들은 Java (bytecode 실행),

219
00:12:00,930 --> 00:12:04,510
Python, JavaScript, Ruby 등이 있습니다.

220
00:12:04,510 --> 00:12:06,130
페이지 17

221
00:12:06,130 --> 00:12:09,160
Java 프로그램의 실행 과정을 다시 살펴보면,

222
00:12:09,160 --> 00:12:12,140
Compile time에는 java source code를

223
00:12:12,140 --> 00:12:16,220
compiler가 bytecode 프로그램으로 translate합니다.

224
00:12:16,220 --> 00:12:19,980
이 bytecode 프로그램은 software로 구현된

225
00:12:19,980 --> 00:12:22,980
Java Virtual Machine (JVM) 내에서

226
00:12:22,980 --> 00:12:26,380
한 줄씩 interpreting되면서 실행됩니다.

227
00:12:26,380 --> 00:12:29,800
Interpreting 과정이 상대적으로 느리기 때문에

228
00:12:29,800 --> 00:12:33,540
속도를 보완할 여러가지 장치들이 연구되었습니다.

229
00:12:33,540 --> 00:12:39,370
JVM 에는 JIT, 즉 Just-In-Time Compiler라는 장치로

230
00:12:39,370 --> 00:12:42,770
interpretation의 속도를 빠르게 하고 있습니다.

231
00:12:42,770 --> 00:12:46,560
JIT는 자주 나올 법한 byte code 부분을

232
00:12:46,560 --> 00:12:51,030
미리 JVM이 구동 중인 실제 컴퓨터의 machine 언어로

233
00:12:51,030 --> 00:12:52,810
compile 해 둡니다.

234
00:12:52,810 --> 00:12:56,810
나중에 다시 그 byte code 부분이 실제로 출현하면

235
00:12:56,810 --> 00:13:00,470
즉시 미리 compile 해 둔 machine 언어 버전을 사용하여

236
00:13:00,470 --> 00:13:03,210
빠른 실행이 가능하게 하는 것입니다.

237
00:13:03,210 --> 00:13:04,780
페이지 18

238
00:13:04,780 --> 00:13:08,200
이제 Java 언어의 특징들을 정리해 보겠습니다.

239
00:13:08,200 --> 00:13:11,390
먼저 Java는 class를 기본 단위로 하는

240
00:13:11,390 --> 00:13:14,110
object-oriented 언어 입니다.

241
00:13:14,110 --> 00:13:18,080
또, bytecode와 JVM을 사용한 메카니즘으로

242
00:13:18,080 --> 00:13:23,100
똑같은 source code를 컴퓨터 하드웨어의 종류나 OS에 상관없이

243
00:13:23,100 --> 00:13:24,930
실행할 수 있습니다.

244
00:13:24,930 --> 00:13:28,640
이같은 특징을 “platform independent” 라고 합니다.

245
00:13:28,640 --> 00:13:31,170
Java 언어는 프로그램 실행 중에

246
00:13:31,170 --> 00:13:34,800
더 이상 쓰이지 않고 있는 memory를 자동으로 모아서

247
00:13:34,800 --> 00:13:37,460
재 사용 가능하도록 관리해 주는데

248
00:13:37,460 --> 00:13:41,040
이러한 기능을 “자동 Garbage Collection” 이라 합니다.

249
00:13:41,040 --> 00:13:46,420
이 기능 덕분에 Java는 C++ 에서와 같은 복잡한 pointer나

250
00:13:46,420 --> 00:13:50,600
dynamic memory management가 없기 때문에 배우기 쉽습니다.

251
00:13:50,600 --> 00:13:53,160
Static typing을 사용하기 때문에

252
00:13:53,160 --> 00:13:57,000
엄격한 데이터 type에 대한 규칙이 지켜져야 하는데

253
00:13:57,000 --> 00:14:00,840
이는 programmer의 실수를 방지하는데 도움이 됩니다.

254
00:14:00,840 --> 00:14:02,380
Java는 또한

255
00:14:02,380 --> 00:14:07,060
process보다 작은 thread 단위의 job들이 동시에 실행되도록

256
00:14:07,060 --> 00:14:10,190
프로그래밍 할 수 있는 기능을 가지고 있습니다.

257
00:14:10,190 --> 00:14:13,140
Java는 뛰어난 Networking 기능을 제공하며, .

258
00:14:13,140 --> 00:14:18,570
JIT 등으로 interpreter의 한계를 극복하여 빠른 실행이 가능합니다.

259
00:14:18,570 --> 00:14:23,320
JVM만 구현되면 새로운 platform에서도 쉽게 실행이 가능하며,

260
00:14:23,320 --> 00:14:27,470
유용한 많은 standard library 들이 제공되고 있습니다.

261
00:14:27,470 --> 00:14:29,010
페이지 19

262
00:14:29,010 --> 00:14:31,830
Java의 특징을 한눈에 훑어보기 위해

263
00:14:31,830 --> 00:14:35,960
Java와 Python 언어의 차이점들을 알아보도록 하겠습니다.

264
00:14:35,960 --> 00:14:38,620
먼저 program 구조를 살펴보면

265
00:14:38,620 --> 00:14:43,270
Python 은 class를 사용하지 않고도 program 작성이 가능합니다.

266
00:14:43,270 --> 00:14:46,640
물론 Python 언어도 OOP 개념을 가지고 있으며,

267
00:14:46,640 --> 00:14:49,230
class 도 정의할 수 있습니다만

268
00:14:49,230 --> 00:14:52,520
class를 반드시 사용해야 하는 것은 아닙니다.

269
00:14:52,520 --> 00:14:55,860
그러나 Java 프로그램의 경우에는 모든 것이

270
00:14:55,860 --> 00:14:58,110
class에 속해 있어야 합니다.

271
00:14:58,110 --> 00:15:03,670
이 example 프로그램의 경우는 PythonVSJava 라는 class 하나가

272
00:15:03,670 --> 00:15:06,150
프로그램 전체를 이루고 있습니다.

273
00:15:06,150 --> 00:15:07,530
페이지 20

274
00:15:07,530 --> 00:15:09,570
Type system 측면에서 보면,

275
00:15:09,570 --> 00:15:13,620
Python 에서는 variable의 type이 고정되지 않습니다.

276
00:15:13,620 --> 00:15:18,740
이 예제에서 보면 variable x는 value 5가 assign이 되는 순간

277
00:15:18,740 --> 00:15:20,230
“integer” type이 되며,

278
00:15:20,230 --> 00:15:23,210
“Hello” 를 다시 x에 assign 하는 순간에

279
00:15:23,210 --> 00:15:26,060
x는 String type으로 변화합니다.

280
00:15:26,060 --> 00:15:30,710
그러나 Java에서는 이러한 자유로운 type 변화는 불가능 합니다.

281
00:15:30,710 --> 00:15:34,680
모든 variable들은 사용되기 전에 그 type이 고정되며,

282
00:15:34,680 --> 00:15:38,830
프로그램 실행 중간에 variable의 type을 바꿀 수 없습니다.

283
00:15:38,830 --> 00:15:42,070
또 Python에서는 variable이 사용되기 전에

284
00:15:42,070 --> 00:15:46,410
반드시 그 type을 알리는 declaration이 필요하지 않습니다.

285
00:15:46,410 --> 00:15:50,460
그러나 Java에서 variable은 반드시 declare 된 이후

286
00:15:50,460 --> 00:15:52,260
사용되어야 합니다.

287
00:15:52,260 --> 00:15:53,880
페이지 21

288
00:15:53,880 --> 00:15:57,960
Python에서는 function이 “def” 문을 사용하여 정의됩니다.

289
00:15:57,960 --> 00:16:02,220
Java에서는 class에 속한 method로 function이 구현됩니다.

290
00:16:02,220 --> 00:16:03,870
페이지 22

291
00:16:03,870 --> 00:16:06,800
Python에도 class구조가 존재합니다.

292
00:16:06,800 --> 00:16:10,560
class는 variable들과 function들을 포함합니다.

293
00:16:10,560 --> 00:16:13,930
이 example에서는 name과 age라는

294
00:16:13,930 --> 00:16:16,440
variable이 class에 포함되고

295
00:16:16,440 --> 00:16:20,250
__init__ 과

296
00:16:20,250 --> 00:16:22,710
say_hello 는 function들 입니다.

297
00:16:22,710 --> 00:16:27,070
특히 __init__ 은

298
00:16:27,070 --> 00:16:29,390
constructor (생성자) 로서

299
00:16:29,390 --> 00:16:33,620
Class object가 생성되는 순간에 자동으로 실행 됩니다.

300
00:16:33,620 --> 00:16:38,140
Java는 프로그램 전체가 한 개 이상의 class들로 구성됩니다.

301
00:16:38,140 --> 00:16:40,490
이 예에서도 class Person은

302
00:16:40,490 --> 00:16:44,040
name과 age라는 두 개의 data를 가지고 있고

303
00:16:44,040 --> 00:16:47,850
constructor인 Person method와 sayHello() method를

304
00:16:47,850 --> 00:16:49,520
가지고 있습니다.

305
00:16:49,520 --> 00:16:51,240
페이지 23

306
00:16:51,240 --> 00:16:56,360
Python에는 전통적인 array의 개념과 유사한 list 구조가 있습니다.

307
00:16:56,360 --> 00:16:59,390
List 구조는 array보다 훨씬 더 유연하며,

308
00:16:59,390 --> 00:17:01,710
많은 기능을 가지고 있습니다.

309
00:17:01,710 --> 00:17:06,260
Java에는 각 type마다 array를 만드는 메카니즘이 존재합니다.

310
00:17:06,260 --> 00:17:10,490
또 ArrayList와 같은 collection framework을 사용하면

311
00:17:10,490 --> 00:17:13,730
훨씬 더 많은 기능들을 사용할 수 있습니다.

312
00:17:13,730 --> 00:17:15,380
페이지 24

313
00:17:15,380 --> 00:17:19,870
Code 블럭의 경우 Python은 별다른 구분자를 사용하지 않고

314
00:17:19,870 --> 00:17:23,030
띄어쓰기로 같은 block을 표현하게 됩니다.

315
00:17:23,030 --> 00:17:25,750
Java의 경우는 중괄호 (brace) { } 로

316
00:17:25,750 --> 00:17:28,880
begin과 end를 명확히 표시하고 있습니다.

317
00:17:28,880 --> 00:17:30,550
페이지 25

318
00:17:30,550 --> 00:17:34,990
Python의 경우 for 문은 list안에 속하는 element들에 대해

319
00:17:34,990 --> 00:17:37,550
반복적인 연산을 수행합니다.

320
00:17:37,550 --> 00:17:41,830
이 예에서는 fruits라는 list 안의 fruit 들에 대해서

321
00:17:41,830 --> 00:17:47,110
또 0부터 4까지의 integer에 대해서 반복되는 연산을 수행합니다.

322
00:17:47,110 --> 00:17:52,230
Java의 경우에도 비슷하게 for문은 array내의 각 element들에 대한

323
00:17:52,230 --> 00:17:55,290
반복적인 연산을 수행할 수 있게 합니다.

324
00:17:55,290 --> 00:17:59,370
또한, 정수 i를 0부터 4까지 증가시키면서

325
00:17:59,370 --> 00:18:02,190
연산을 수행할 수 있게 할 수 있습니다.

326
00:18:02,190 --> 00:18:03,840
페이지 26

327
00:18:03,840 --> 00:18:08,150
Python과 Java는 모두 interpretation을 사용하기 때문에

328
00:18:08,150 --> 00:18:11,180
기본적으로 프로그램 수행이 느려집니다.

329
00:18:11,180 --> 00:18:15,880
그러나 Java의 경우에는 JIT와 같은 메카니즘을 사용하여

330
00:18:15,880 --> 00:18:18,680
수행 속도를 더 빠르게 할 수 있습니다.

331
00:18:18,680 --> 00:18:23,380
Python은 비교적 간단한 문법을 가지고 있고 배우기 쉽습니다.

332
00:18:23,380 --> 00:18:27,190
그에 비하면 Java는 매우 엄격한 문법을 가지고 있는데,

333
00:18:27,190 --> 00:18:30,270
이 때문에 프로그래머가 의식하지 못한 채

334
00:18:30,270 --> 00:18:34,450
error를 포함한 프로그램을 작성하는 것을 방지할 수 있습니다.

335
00:18:34,450 --> 00:18:40,090
Python은 과학, 공학에 광범위하게 사용되는 library 함수들을

336
00:18:40,090 --> 00:18:41,680
포함하고 있으며

337
00:18:41,680 --> 00:18:46,070
Java에는 기본적으로 제공되는 standard library가 풍부하고,

338
00:18:46,070 --> 00:18:51,010
기업 어플리케이션을 위한 써드파티 library들이 많이 존재합니다.

339
00:18:51,010 --> 00:18:56,550
따라서 Python은 수행속도가 중요시되지 않는 연구 분야의 프로토타이핑,

340
00:18:56,550 --> 00:19:00,210
데이터 분석, 기계학습 등에 널리 사용되고 있으며,

341
00:19:00,210 --> 00:19:03,160
Java는 서버 구현과 같은 기업 솔루션,

342
00:19:03,160 --> 00:19:07,100
클라우드 구현, 안드로이드 어플리케이션 구현 등에

343
00:19:07,100 --> 00:19:09,140
많이 사용되고 있습니다.
