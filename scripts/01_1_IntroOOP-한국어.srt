1
00:00:00,000 --> 00:00:01,460
페이지 1

2
00:00:01,460 --> 00:00:05,120
이번 강의에서는 객체지향프로그래밍의 개념에 대해

3
00:00:05,120 --> 00:00:06,820
알아보겠습니다

4
00:00:06,820 --> 00:00:08,230
페이지 2

5
00:00:08,230 --> 00:00:10,740
Object-Oriented Programming,

6
00:00:10,740 --> 00:00:13,250
즉, 객체지향프로그래밍,

7
00:00:13,250 --> 00:00:16,650
줄여서 OOP라 표시하는 이것은 무엇일까요?

8
00:00:16,650 --> 00:00:19,170
OOP는 Object 개념을 기반으로 하는

9
00:00:19,170 --> 00:00:21,560
프로그래밍 패러다임입니다

10
00:00:21,560 --> 00:00:23,750
여기서 Object란, data와,

11
00:00:23,750 --> 00:00:27,900
이를 처리하는 operation (또는 method, function)을

12
00:00:27,900 --> 00:00:30,590
하나의 단위로 묶은 것을 말합니다

13
00:00:30,590 --> 00:00:32,700
OOP는 1960년대에

14
00:00:32,700 --> 00:00:35,990
코드의 유지보수와 재사용 가능성을 높이기 위해

15
00:00:35,990 --> 00:00:37,750
개발되었습니다

16
00:00:37,750 --> 00:00:40,960
Smalltalk 과 같은 언어를 통해 처음 소개되었으며,

17
00:00:40,960 --> 00:00:44,160
이후 C++와 Java 같은 언어들에 의해

18
00:00:44,160 --> 00:00:46,080
널리 사용되었습니다

19
00:00:46,080 --> 00:00:47,810
요즘의 프로그래밍 언어들은

20
00:00:47,810 --> 00:00:51,830
대부분 OOP 언어적인 특징들을 갖추고 있습니다

21
00:00:51,830 --> 00:00:58,730
그 예로는 Java, C++, Python, C#, Ruby, Swift, Kotlin,

22
00:00:58,730 --> 00:01:02,100
Javascript, Dart, Go 등이 있습니다

23
00:01:02,100 --> 00:01:03,620
페이지 3

24
00:01:03,620 --> 00:01:06,860
OOP를 사용하면 어떤 장점이 있을까요?

25
00:01:06,860 --> 00:01:09,050
첫째, 모듈성입니다

26
00:01:09,050 --> 00:01:12,530
코드를 독립된 오브젝트들로 나누어 작성함으로써

27
00:01:12,530 --> 00:01:14,930
코드 관리가 용이해집니다

28
00:01:14,930 --> 00:01:17,330
둘째, 재사용성입니다

29
00:01:17,330 --> 00:01:18,990
한 번 작성한 오브젝트는

30
00:01:18,990 --> 00:01:22,060
여러 프로그램에서 재사용할 수 있습니다

31
00:01:22,060 --> 00:01:24,250
셋째, 확장성입니다

32
00:01:24,250 --> 00:01:26,240
대규모 프로그래밍 프로젝트도

33
00:01:26,240 --> 00:01:28,740
체계적으로 관리할 수 있습니다

34
00:01:28,740 --> 00:01:31,480
넷째, 유지보수가 용이합니다

35
00:01:31,480 --> 00:01:34,670
즉, 디버깅과 업데이트가 쉽습니다

36
00:01:34,670 --> 00:01:36,790
페이지 4

37
00:01:36,790 --> 00:01:41,200
Procedural 프로그래밍, 즉, 절차적 프로그래밍과

38
00:01:41,200 --> 00:01:43,640
Object-Oriented Programming,

39
00:01:43,640 --> 00:01:47,440
즉, 객체지향 프로그래밍을 비교해봅시다

40
00:01:47,440 --> 00:01:49,120
Procedural 프로그래밍은

41
00:01:49,120 --> 00:01:52,800
function과 procedure를 중심으로 코드를 작성하며,

42
00:01:52,800 --> 00:01:56,850
주로 top-down 즉 하향식 구조로 되어 있습니다

43
00:01:56,850 --> 00:01:59,190
반면, OOP는 Object들과

44
00:01:59,190 --> 00:02:03,010
그들의 interaction을 중심으로 코드를 작성합니다

45
00:02:03,010 --> 00:02:05,330
Object는 real world의 개체들을

46
00:02:05,330 --> 00:02:08,630
좀 더 자연스럽게 모델링할 수 있게 합니다

47
00:02:08,630 --> 00:02:10,120
페이지 5

48
00:02:10,120 --> 00:02:13,150
Procedural 프로그래밍 기법을 사용한

49
00:02:13,150 --> 00:02:15,940
Python 코드를 보도록 하겠습니다

50
00:02:15,940 --> 00:02:19,450
먼저 학생들의 이름과 성적을 저장하기 위한 list인

51
00:02:19,450 --> 00:02:22,370
student_grades 를 준비합니다

52
00:02:22,370 --> 00:02:25,460
function "add_student_grade" 를 정의하는데,

53
00:02:25,460 --> 00:02:28,590
학생 이름과 성적을 parameter로 받아

54
00:02:28,590 --> 00:02:31,410
student_grades list에 추가합니다

55
00:02:31,410 --> 00:02:35,120
list의 "append" function이 이를 위해 사용됩니다

56
00:02:35,120 --> 00:02:37,120
Function "get_average_grade"는

57
00:02:37,120 --> 00:02:39,640
현재 list 안의 모든 grade들의

58
00:02:39,640 --> 00:02:41,960
평균을 구하는 것입니다.

59
00:02:41,960 --> 00:02:44,960
지금까지 이렇게 보면 프로그램에 사용되는 데이터인

60
00:02:44,960 --> 00:02:49,170
list와 function들이 모두 독립적으로 정의되어 있습니다

61
00:02:49,170 --> 00:02:52,230
이제 procedure, 즉 function들을 실행시키면서

62
00:02:52,230 --> 00:02:54,730
원하는 작업을 완성합니다

63
00:02:54,730 --> 00:02:58,180
먼저 add_student_grade를 두번 call하여

64
00:02:58,180 --> 00:03:00,800
Alice와 Bob이라는 두 학생의 성적들을

65
00:03:00,800 --> 00:03:04,060
student_grades list에 저장합니다.

66
00:03:04,060 --> 00:03:07,030
그 다음에 get_average_grade function을 call하여

67
00:03:07,030 --> 00:03:10,720
평균 점수를 계산하고, 화면에 출력합니다.

68
00:03:10,720 --> 00:03:12,180
페이지 6

69
00:03:12,180 --> 00:03:14,840
이 Python program은 OOP 의 특징을

70
00:03:14,840 --> 00:03:16,880
잘 보여주고 있습니다.

71
00:03:16,880 --> 00:03:19,010
Object를 나타내는 Class들이

72
00:03:19,010 --> 00:03:21,660
정의되어 있는 것을 볼 수 있습니다.

73
00:03:21,660 --> 00:03:25,470
먼저 Student class에는 data로 name과 grade라는

74
00:03:25,470 --> 00:03:27,250
두 변수를 가지고 있어서,

75
00:03:27,250 --> 00:03:29,300
학생들의 이름과 성적을 저장하는

76
00:03:29,300 --> 00:03:32,790
하나의 entry object를 나타내고 있습니다.

77
00:03:32,790 --> 00:03:34,830
Classroom object는 data로

78
00:03:34,830 --> 00:03:37,570
students list를 가지고 있습니다.

79
00:03:37,570 --> 00:03:40,880
Constructor, 즉, 생성자에서는 list를

80
00:03:40,880 --> 00:03:43,210
빈 list로 초기화 합니다.

81
00:03:43,210 --> 00:03:45,480
Classroom class는 data 이외에

82
00:03:45,480 --> 00:03:49,270
data를 다루는 function들을 함께 가지고 있습니다.

83
00:03:49,270 --> 00:03:52,640
먼저 add_student function은 주어진 학생 이름과

84
00:03:52,640 --> 00:03:53,910
점수 parameter로

85
00:03:53,910 --> 00:03:57,840
students list에 하나의 entry를 추가합니다.

86
00:03:57,840 --> 00:03:59,740
get_average_grade function은

87
00:03:59,740 --> 00:04:04,870
현재 list에 있는 모든 entry들의 점수의 평균을 계산합니다.

88
00:04:04,870 --> 00:04:08,430
이렇게 OOP에서는 data와 function (혹은 method) 들이

89
00:04:08,430 --> 00:04:11,400
함께 하나의 object를 이루게 됩니다.

90
00:04:11,400 --> 00:04:15,890
프로그램 실행은 object들을 적절한 data와 함께 생성하고,

91
00:04:15,890 --> 00:04:19,550
object들의 method를 call 하는 것으로 이루어 집니다.

92
00:04:19,550 --> 00:04:23,680
여기서는 Classroom class의 object를 하나 생성한 후

93
00:04:23,680 --> 00:04:27,140
그 object의 add_student function을 두번 call하여

94
00:04:27,140 --> 00:04:30,760
두 개의 data entry를 list에 추가합니다.

95
00:04:30,760 --> 00:04:33,340
이 때 추가하는 data entry parameter가

96
00:04:33,340 --> 00:04:37,190
Student class의 object임을 볼 수 있습니다.

97
00:04:37,190 --> 00:04:38,680
Data가 추가되고 나면

98
00:04:38,680 --> 00:04:42,210
classroom object의 get_average_grade function을

99
00:04:42,210 --> 00:04:46,720
call하여 평균을 계산한 후 화면에 출력합니다.

100
00:04:46,720 --> 00:04:49,960
이 example에서 procedural programming과

101
00:04:49,960 --> 00:04:52,000
object-oriented programming의

102
00:04:52,000 --> 00:04:55,030
차이가 없는 것처럼 보일 수도 있습니다.

103
00:04:55,030 --> 00:04:58,170
그러나 OOP에서는 Student와 Classroom이

104
00:04:58,170 --> 00:05:01,800
data + function의 조합으로 이루어진 class이며,

105
00:05:01,800 --> 00:05:03,990
이 class들은 그 코드를

106
00:05:03,990 --> 00:05:06,690
그대로 다른 프로그램에 이식하여 사용하거나

107
00:05:06,690 --> 00:05:10,570
관리하기에 편하게 되어있다는 점을 강조하고 싶습니다.
