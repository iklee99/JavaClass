1
00:00:00,000 --> 00:00:04,390
In this lecture, we will cover the basic programming part

2
00:00:04,390 --> 00:00:08,100
before the object-oriented part in the Java language

3
00:00:08,100 --> 00:00:09,300
Page 2 First, let's look at

4
00:00:09,300 --> 00:00:13,560
the general structure of a Java program

5
00:00:13,560 --> 00:00:17,900
A Java program must define a class somehow,

6
00:00:17,900 --> 00:00:20,620
because everything in it must be part of a class

7
00:00:20,620 --> 00:00:25,110
In this example, a class called HelloWorld1 is defined

8
00:00:25,110 --> 00:00:29,130
public is a keyword called an access modifier,

9
00:00:29,130 --> 00:00:33,730
which means that this class can be used by any other class

10
00:00:33,730 --> 00:00:37,390
class is a keyword that defines a class type

11
00:00:37,390 --> 00:00:42,200
The class name follows, which in this example is HelloWorld1

12
00:00:42,200 --> 00:00:45,130
As mentioned before, the class name

13
00:00:45,130 --> 00:00:48,370
must match the name in the java source file

14
00:00:48,370 --> 00:00:51,920
The class body begins with a left brace

15
00:00:51,920 --> 00:00:55,500
{ and the class ends with a right brace }

16
00:00:55,500 --> 00:00:56,780
Page 3 Inside the class body,

17
00:00:56,780 --> 00:01:01,720
there are various fields that represent data

18
00:01:01,720 --> 00:01:05,350
belonging to the class and methods that represent operations

19
00:01:05,350 --> 00:01:10,260
The class in this example has no data, i.e. no fields

20
00:01:10,260 --> 00:01:13,550
It has only one method, main

21
00:01:13,550 --> 00:01:18,410
The main method is the first method executed when the program starts

22
00:01:18,410 --> 00:01:22,620
Therefore, if it is an executable program (class),

23
00:01:22,620 --> 00:01:25,490
it must have a Main method

24
00:01:25,490 --> 00:01:26,770
The first thing that appears

25
00:01:26,770 --> 00:01:30,060
in the header of the main method on page 4

26
00:01:30,060 --> 00:01:33,610
is the access modifier, public

27
00:01:33,610 --> 00:01:37,400
This public can be understood

28
00:01:37,400 --> 00:01:41,000
as allowing the OS to call main to run the program

29
00:01:41,000 --> 00:01:45,260
The static that follows indicates that the main method

30
00:01:45,260 --> 00:01:48,210
is a static method within this class

31
00:01:48,210 --> 00:01:52,890
In simple terms, this means that all objects created using this class

32
00:01:52,890 --> 00:01:56,340
as a template share just one main method

33
00:01:56,340 --> 00:02:00,050
It may be difficult to fully understand the meaning of static yet,

34
00:02:00,050 --> 00:02:02,900
but we will learn more about it later

35
00:02:02,900 --> 00:02:07,080
void means that the main method has no return value

36
00:02:07,080 --> 00:02:10,710
Methods, that is, functions,

37
00:02:10,710 --> 00:02:13,920
can often return a value or not

38
00:02:13,920 --> 00:02:19,220
If there is a function f such that f(a, b)

39
00:02:19,220 --> 00:02:23,090
= a + b, the return value could be a + b

40
00:02:23,090 --> 00:02:27,580
However, some functions (methods) may only execute a series of tasks sequentially

41
00:02:27,580 --> 00:02:31,370
without returning a value

42
00:02:31,370 --> 00:02:33,980
main is the name of the method

43
00:02:33,980 --> 00:02:37,450
The String[] args inside the parentheses after that

44
00:02:37,450 --> 00:02:39,980
are the type and name of the parameter

45
00:02:39,980 --> 00:02:44,240
In the previous example, the function

46
00:02:44,240 --> 00:02:47,240
f(a, b), or method, takes two parameters

47
00:02:47,240 --> 00:02:49,750
a and b and performs some calculation

48
00:02:49,750 --> 00:02:52,010
For the Main method,

49
00:02:52,010 --> 00:02:54,950
these parameters are called Command line arguments,

50
00:02:54,950 --> 00:02:59,050
which are parameters attached to the command that runs the program

51
00:02:59,050 --> 00:03:04,300
For example, if you run a program called “javac -version”,

52
00:03:04,300 --> 00:03:07,220
javac is the name of the program

53
00:03:07,220 --> 00:03:11,590
and -version is passed to the program as command line arguments

54
00:03:11,590 --> 00:03:16,470
However, we are not using these command line arguments yet

55
00:03:16,470 --> 00:03:18,770
The bracket symbol in String[]

56
00:03:18,770 --> 00:03:22,900
indicates that args is an array type of String

57
00:03:22,900 --> 00:03:27,310
For example, if we consider running the program “foo 3

58
00:03:27,310 --> 00:03:33,340
Seoul 7”, args[0] = “3”,

59
00:03:33,340 --> 00:03:34,650
args[1] = “Seoul”, args[2] = “7”

60
00:03:34,650 --> 00:03:39,120
Page 5 Comments in Java have the same format as in C or C++

61
00:03:39,120 --> 00:03:43,170
First, there are multi-line comments that start with a slash star

62
00:03:43,170 --> 00:03:45,470
/* and end with a star slash */

63
00:03:45,470 --> 00:03:49,020
You can also start with a slash double star,

64
00:03:49,020 --> 00:03:53,360
in which case you can use JavaDoc,

65
00:03:53,360 --> 00:03:58,580
one of Java's utilities, to automatically create API documentation

66
00:03:58,580 --> 00:04:03,070
However, we will not discuss this further in this course

67
00:04:03,070 --> 00:04:07,150
and you are encouraged to consult other references if necessary

68
00:04:07,150 --> 00:04:10,940
A single-line comment starts with a double slash

69
00:04:10,940 --> 00:04:14,390
// and everything on the same line is considered a comment until the end

70
00:04:14,390 --> 00:04:15,670
Page 6

71
00:04:15,670 --> 00:04:18,700
The following is about a statement block,

72
00:04:18,700 --> 00:04:22,930
which starts with a left brace { and closes with a right brace }

73
00:04:22,930 --> 00:04:27,660
This block serves to group

74
00:04:27,660 --> 00:04:33,170
multiple statements that make up the body of an If,

75
00:04:33,170 --> 00:04:35,360
for, or while statement, while creating a new scope for local variables

76
00:04:35,360 --> 00:04:39,020
Of course, the beginning and end of the entire method can be considered as one block,

77
00:04:39,020 --> 00:04:43,670
and the beginning and end of the entire class can also be considered as one block

78
00:04:43,670 --> 00:04:48,610
We will discuss the scope of variables in more detail later

79
00:04:48,610 --> 00:04:49,970
Page 7

80
00:04:49,970 --> 00:04:53,840
The following is an identifier

81
00:04:53,840 --> 00:04:58,860
An identifier is simply a name that a programmer must create,

82
00:04:58,860 --> 00:05:04,660
such as a variable, constant, method, parameter, or class

83
00:05:04,660 --> 00:05:09,620
Identifiers in Java follow the case sensitive rule

84
00:05:09,620 --> 00:05:15,920
That is, if uppercase and lowercase letters of the alphabet are used, they are recognized as different identifiers

85
00:05:15,920 --> 00:05:22,160
Also, keywords used in Java grammar cannot be used as identifiers

86
00:05:22,160 --> 00:05:26,030
For example, class, public, void, etc

87
00:05:26,030 --> 00:05:30,260
There are only two rules that must be followed

88
00:05:30,260 --> 00:05:32,900
when naming an identifier:

89
00:05:32,900 --> 00:05:36,790
it cannot start with a numeric character and no special characters

90
00:05:36,790 --> 00:05:39,560
other than the dollar sign ($) and the underscore (_) can be used

91
00:05:39,560 --> 00:05:42,120
However, there is a general convention for naming identifiers

92
00:05:42,120 --> 00:05:45,250
in the Java language

93
00:05:45,250 --> 00:05:48,440
It is recommended that variables and methods use camelCase, that is,

94
00:05:48,440 --> 00:05:53,660
they start with a lowercase letter and capitalize the first letter

95
00:05:53,660 --> 00:05:56,320
when the word changes, and class names use PascalCase, that is,

96
00:05:56,320 --> 00:06:01,520
they start with an uppercase letter

97
00:06:01,520 --> 00:06:03,400
and capitalize the first letter when the word changes

98
00:06:03,400 --> 00:06:04,760
Page 8 There are two types of data types in Java

99
00:06:04,760 --> 00:06:07,840
The first is the primitive type

100
00:06:07,840 --> 00:06:10,580
and the second is the reference type

101
00:06:10,580 --> 00:06:13,380
Primitive types are types

102
00:06:13,380 --> 00:06:16,590
that basically have only one value,

103
00:06:16,590 --> 00:06:20,140
such as integers and real numbers

104
00:06:20,140 --> 00:06:24,240
Therefore, primitive types are not treated as classes

105
00:06:24,240 --> 00:06:28,970
On the other hand, reference types refer to all classes

106
00:06:28,970 --> 00:06:32,340
such as String, and types such as Array, enumeration, etc

107
00:06:32,340 --> 00:06:37,150
Strictly speaking, a reference is a concept similar to an address in memory,

108
00:06:37,150 --> 00:06:41,330
and can be seen as having the address of the memory where complex data

109
00:06:41,330 --> 00:06:44,600
such as a class are gathered as its value

110
00:06:44,600 --> 00:06:49,170
We will learn more about reference types later

111
00:06:49,170 --> 00:06:55,570
There are four types of primitive types:

112
00:06:55,570 --> 00:06:59,910
integer, real number, character, and boolean

113
00:06:59,910 --> 00:07:03,380
There are four types of integers:

114
00:07:03,380 --> 00:07:07,120
byte type of 8 bits (i.e

115
00:07:07,120 --> 00:07:11,330
1 byte), short type of 16 bits (2 bytes), int type of 32 bits

116
00:07:11,330 --> 00:07:13,320
(4 bytes), and long type of 64 bits (8 bytes)

117
00:07:13,320 --> 00:07:18,880
There are 32-bit float and 64-bit double types

118
00:07:18,880 --> 00:07:22,430
The character type is char, which is 16 bits

119
00:07:22,430 --> 00:07:27,180
In Boolean type, there is a boolean type

120
00:07:27,180 --> 00:07:29,220
that can have only one value, either true or false

121
00:07:29,220 --> 00:07:30,580
Let's look at an example program for Page

122
00:07:30,580 --> 00:07:34,370
9 Data type

123
00:07:34,370 --> 00:07:38,050
First, I declared myNumber, which is an int type, and initialized its value to 10

124
00:07:38,050 --> 00:07:40,900
In the case of yourNumber,

125
00:07:40,900 --> 00:07:45,940
declaration and initialization are sometimes done at the same time

126
00:07:45,940 --> 00:07:51,350
Literal refers to numbers, characters, strings, etc. that are directly given here

127
00:07:51,350 --> 00:07:55,090
When assigning a literal to float type f1,

128
00:07:55,090 --> 00:07:58,980
you must add f at the end of the number to distinguish it from double

129
00:07:58,980 --> 00:08:03,030
Instead, when assigning a literal to a double type,

130
00:08:03,030 --> 00:08:05,280
you can just use a number

131
00:08:05,280 --> 00:08:06,560
Page 10 Let's look at a case

132
00:08:06,560 --> 00:08:09,150
where we assign the value of a variable of a different

133
00:08:09,150 --> 00:08:13,410
type to a variable of a different type

134
00:08:13,410 --> 00:08:15,870
myInt is of int type

135
00:08:15,870 --> 00:08:20,650
The value of myInt was assigned to myDouble, which is a double type

136
00:08:20,650 --> 00:08:24,930
The reason why you can just assign without any other device at this time

137
00:08:24,930 --> 00:08:29,450
is because the data range of double type is much wider than that of int

138
00:08:29,450 --> 00:08:32,770
This method is called implicit conversion

139
00:08:32,770 --> 00:08:38,070
The value 10 of myInt becomes 10.0 when assigned to double

140
00:08:38,070 --> 00:08:41,860
On the other hand, when assigning myDouble to myInt,

141
00:08:41,860 --> 00:08:47,740
you must explicitly convert by attaching the casting operator (Int)

142
00:08:47,740 --> 00:08:50,670
When casting from double to int, the decimal point is discarded

143
00:08:50,670 --> 00:08:54,900
and only the integer part remains

144
00:08:54,900 --> 00:09:00,330
So the double value 9.78 is converted to the int value 9

145
00:09:00,330 --> 00:09:01,820
Page 11 Named constants

146
00:09:01,820 --> 00:09:06,760
are used to represent specific values as identifiers,

147
00:09:06,760 --> 00:09:08,950
making their meaning clear

148
00:09:08,950 --> 00:09:13,130
and allowing programs to use names instead of numbers

149
00:09:13,130 --> 00:09:17,960
In this example, the value INCHES_PER_FOOT is defined as 12,

150
00:09:17,960 --> 00:09:21,930
and since 1 foot equals 12 inches,

151
00:09:21,930 --> 00:09:26,680
this value can be set as a constant

152
00:09:26,680 --> 00:09:29,680
RATE is fixed at 0.14, and you can expect it to represent some specific rate,

153
00:09:29,680 --> 00:09:34,510
such as an interest rate

154
00:09:34,510 --> 00:09:39,320
In this way, once a named constant's value

155
00:09:39,320 --> 00:09:42,740
is defined, its value cannot be changed within the program

156
00:09:42,740 --> 00:09:44,500
Any attempt to change

157
00:09:44,500 --> 00:09:46,890
this will result in a Compile error

158
00:09:46,890 --> 00:09:50,970
Keywords such as public static final are attached,

159
00:09:50,970 --> 00:09:54,420
and here final means constant

160
00:09:54,420 --> 00:09:57,790
and indicates that the value cannot be changed

161
00:09:57,790 --> 00:10:02,750
When naming identifiers that represent naming constants,

162
00:10:02,750 --> 00:10:05,050
it is generally recommended to use only uppercase letters

163
00:10:05,050 --> 00:10:07,770
and use underscores (_) between words

164
00:10:07,770 --> 00:10:09,290
Page 12 The String type is a class type

165
00:10:09,290 --> 00:10:14,830
included in the basic package provided by Java

166
00:10:14,830 --> 00:10:19,480
It is a reference type used to handle text strings

167
00:10:19,480 --> 00:10:23,760
The three Strings greeting, firstName, and lastName are initialized to “Hello World!”,

168
00:10:23,760 --> 00:10:27,840
“John”, and “Doe”, respectively

169
00:10:27,840 --> 00:10:31,470
Strings can be concatenated, or joined together,

170
00:10:31,470 --> 00:10:34,550
using the plus operator

171
00:10:34,550 --> 00:10:38,470
You can see that the value of the fullName String

172
00:10:38,470 --> 00:10:41,400
concatenated in the example is printed on the screen

173
00:10:41,400 --> 00:10:42,970
Page 13 For String concatenation,

174
00:10:42,970 --> 00:10:47,620
you can concatenate not only Strings,

175
00:10:47,620 --> 00:10:52,190
but also integer literals such as 42 into a single String,

176
00:10:52,190 --> 00:10:54,780
like in this program

177
00:10:54,780 --> 00:11:00,400
You can also concatenate variables of primitive types or class types,

178
00:11:00,400 --> 00:11:02,700
such as int type k

179
00:11:02,700 --> 00:11:06,540
We'll learn more about what makes this possible

180
00:11:06,540 --> 00:11:09,280
as we study the class

181
00:11:09,280 --> 00:11:10,850
Page 14 A string can be viewed from another perspective

182
00:11:10,850 --> 00:11:15,790
as a collection of characters

183
00:11:15,790 --> 00:11:20,440
However, this does not mean that a String is the same as an array of char types

184
00:11:20,440 --> 00:11:24,460
In C or C++, these two are the same,

185
00:11:24,460 --> 00:11:27,050
but in Java, String is not

186
00:11:27,050 --> 00:11:30,890
However, each character that makes up a Java

187
00:11:30,890 --> 00:11:32,980
String has an index

188
00:11:32,980 --> 00:11:38,200
The 0-based index is useful in several String methods

189
00:11:38,200 --> 00:11:40,210
that we will see later

190
00:11:40,210 --> 00:11:44,130
Note that blank spaces are also considered

191
00:11:44,130 --> 00:11:47,060
as characters

192
00:11:47,060 --> 00:11:48,580
Page 15 The String class

193
00:11:48,580 --> 00:11:52,390
has several methods

194
00:11:52,390 --> 00:11:57,980
First, let's assume that the value of the str String is "Hello, World!"

195
00:11:57,980 --> 00:12:00,960
length() returns the length of the String

196
00:12:00,960 --> 00:12:03,830
If we look at the index of the previous page,

197
00:12:03,830 --> 00:12:08,140
the index of the last character of the String + 1 is equal to the length

198
00:12:08,140 --> 00:12:13,760
charAt(index) returns the character at position index in the string

199
00:12:13,760 --> 00:12:18,850
In this example, charAt(0) returns the uppercase character H

200
00:12:18,850 --> 00:12:23,450
substring(int) returns a subString from the given parameter index

201
00:12:23,450 --> 00:12:26,530
to the very end of the String

202
00:12:26,530 --> 00:12:29,640
In the case of “Hello, World!”,

203
00:12:29,640 --> 00:12:33,400
substring(7) returns “World!” because it starts from Index

204
00:12:33,400 --> 00:12:35,390
7, ‘W’, to the end

205
00:12:35,390 --> 00:12:41,060
substring(0, 5) returns a subString from begin index 0 to end index 5

206
00:12:41,060 --> 00:12:43,360
equals(String other) tests whether the String that

207
00:12:43,360 --> 00:12:47,020
called equals is the same

208
00:12:47,020 --> 00:12:50,340
as the contents of the parameter

209
00:12:50,340 --> 00:12:52,950
other, and returns true or false

210
00:12:52,950 --> 00:12:56,500
equalsIgnoreCase is like equals, but returns true

211
00:12:56,500 --> 00:13:00,180
if they are the same regardless of case

212
00:13:00,180 --> 00:13:01,700
Page 16 str.compareTo(String other) returns

213
00:13:01,700 --> 00:13:06,300
a minus value if str is less than other, 0

214
00:13:06,300 --> 00:13:09,800
if they are equal, and a plus value if they are greater,

215
00:13:09,800 --> 00:13:13,670
based on the lexicographical ordering

216
00:13:13,670 --> 00:13:20,360
str.indexOf(“World”) returns the starting index of the first substring named “World”

217
00:13:20,360 --> 00:13:24,720
in the String str

218
00:13:24,720 --> 00:13:31,620
str.lastIndexOf(“o”) returns the starting index of the last occurrence of “o” in str,

219
00:13:31,620 --> 00:13:35,960
if the substring “o” occurs

220
00:13:35,960 --> 00:13:41,680
str.contains(“Hello”) returns true if the substring “Hello” exists in str

221
00:13:41,680 --> 00:13:43,560
str.replace() has several versions, and replaces characters,

222
00:13:43,560 --> 00:13:47,640
substrings, etc

223
00:13:47,640 --> 00:13:51,400
that appear in str with a second one

224
00:13:51,400 --> 00:13:54,330
str.toUpperCase() returns str with all uppercase letters,

225
00:13:54,330 --> 00:13:59,010
and str.toLowerCase() returns

226
00:13:59,010 --> 00:14:04,810
str with all lowercase letters

227
00:14:04,810 --> 00:14:06,430
Page 17 str.trim() removes all spaces from the beginning

228
00:14:06,430 --> 00:14:13,460
and end of a string

229
00:14:13,460 --> 00:14:19,600
This method is conveniently used when receiving text input in a UI such as the web

230
00:14:19,600 --> 00:14:27,570
String.join(a, b, c) concatenates three Strings in the order b, a, c

231
00:14:27,570 --> 00:14:35,720
String.valueOf(123) returns the integer 123 as the String “123”

232
00:14:35,720 --> 00:14:40,660
Similarly, String.valueOf(true) returns the boolean value true

233
00:14:40,660 --> 00:14:43,380
as a String “true”

234
00:14:43,380 --> 00:14:49,600
str.startsWith(“Hello”) returns true if str starts with “Hello”

235
00:14:49,600 --> 00:14:56,240
str.endsWith(“!”) returns true if str ends with “!”

236
00:14:56,240 --> 00:15:02,770
str.isEmpty() returns true if str is an empty String

237
00:15:02,770 --> 00:15:04,340
Page 18 Escape Sequence is used firstly

238
00:15:04,340 --> 00:15:06,480
when you want to print characters

239
00:15:06,480 --> 00:15:11,780
that are used for special purposes in the program

240
00:15:11,780 --> 00:15:16,670
and secondly when you want to print invisible special characters

241
00:15:16,670 --> 00:15:22,730
Double quote, single quote, and backslash are characters used for special purposes, and new line, carriage

242
00:15:22,730 --> 00:15:27,930
return, and tab are invisible special characters

243
00:15:27,930 --> 00:15:32,530
This example prints using the escape sequences backslash, new line,

244
00:15:32,530 --> 00:15:37,750
double quote, Tab, and single quote

245
00:15:37,750 --> 00:15:39,290
Page 19

246
00:15:39,290 --> 00:15:44,800
Java Strings are immutable, meaning that the contents of a String cannot be changed

247
00:15:44,800 --> 00:15:50,160
If you want to change the contents, use a StringBuffer object instead of a String

248
00:15:50,160 --> 00:15:55,230
Of course, it is possible to change the contents of a String using assignment

249
00:15:55,230 --> 00:15:59,280
This example shows assigning the contents of name to “Soprano”

250
00:15:59,280 --> 00:16:03,380
and then changing it back to “Anthony Soprano”

251
00:16:03,380 --> 00:16:08,450
Strictly speaking, in this case, the memory

252
00:16:08,450 --> 00:16:11,480
originally allocated to name is maintained and its contents do not change

253
00:16:11,480 --> 00:16:16,360
The principle that String is still immutable

254
00:16:16,360 --> 00:16:20,930
is maintained because new memory space is allocated each time a new assignment is made

255
00:16:20,930 --> 00:16:22,310
Page 20 The ASCII character set

256
00:16:22,310 --> 00:16:27,950
is the one most widely used in existing computer systems

257
00:16:27,950 --> 00:16:32,780
This character set contains all the characters found on the English keyboard,

258
00:16:32,780 --> 00:16:35,810
plus some special characters

259
00:16:35,810 --> 00:16:39,360
Since there are 128 characters in total,

260
00:16:39,360 --> 00:16:43,120
the ASCII set can easily be represented in 8 bits

261
00:16:43,120 --> 00:16:45,210
Based on this judgment,

262
00:16:45,210 --> 00:16:48,190
programming languages prior to Java

263
00:16:48,190 --> 00:16:54,330
often defined the size of the Character type as 8 bits (1 byte)

264
00:16:54,330 --> 00:16:58,070
C and C++ are representative examples

265
00:16:58,070 --> 00:16:59,690
Page 21

266
00:16:59,690 --> 00:17:02,980
However, since it was impossible to represent all foreign language characters and various symbols

267
00:17:02,980 --> 00:17:08,410
other than the English alphabet

268
00:17:08,410 --> 00:17:14,570
with only 8 bits, Java represented each character with Unicode, which uses 16 bits instead of 8 bits

269
00:17:14,570 --> 00:17:17,370
So, as you can see when you try it,

270
00:17:17,370 --> 00:17:22,590
it is also possible to have variable names in Korean in Java programs

271
00:17:22,590 --> 00:17:27,550
Of course, this course does not recommend using Korean variable names
